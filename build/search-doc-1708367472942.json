{"searchDocs":[{"title":"Promises","type":0,"sectionRef":"#","url":"/wlx-docs/docs/Event system/promise","content":"Promises warning This chapter is in development. Please see References Promise","keywords":"","version":null},{"title":"Async","type":0,"sectionRef":"#","url":"/wlx-docs/docs/Reference/Misc/Async","content":"","keywords":"","version":null},{"title":"SetTimeout‚Äã","type":1,"pageTitle":"Async","url":"/wlx-docs/docs/Reference/Misc/Async#settimeout","content":" Spawns an asynchronous task (a wrapper over SchelduleTask), that evaluates an expression once  SetTimeout[expr_, interval_Real] _TaskObject   A symbol has HoldFirst attribute. An interval is in milliseconds. To cancel it, use  CancelTimeout[_TaskObject]   ","version":null,"tagName":"h2"},{"title":"SetInterval‚Äã","type":1,"pageTitle":"Async","url":"/wlx-docs/docs/Reference/Misc/Async#setinterval","content":" Spawns an asynchronous task (a wrapper over SchelduleTask), that evaluates an expression every interval milliseconds  SetInterval[expr_, interval_Real] _TaskObject   A symbol has HoldFirst attribute. To cancel this task use  TaskRemove[_TaskObject]   or  CancelInterval[_TaskObject]  ","version":null,"tagName":"h2"},{"title":"Language","type":0,"sectionRef":"#","url":"/wlx-docs/docs/Reference/Misc/Language","content":"","keywords":"","version":null},{"title":"LeakyModule‚Äã","type":1,"pageTitle":"Language","url":"/wlx-docs/docs/Reference/Misc/Language#leakymodule","content":" a Module that cause memory leaks on purpose  A variation of Module, which comes with its own garbage collector, that prevents symbols from being purged by WL  LeakyModule[symbols_List, expr_, opts___] _   The only difference compared to traditional module-function is an optional argument  &quot;Garbage&quot; :&gt; _List a held symbol, that points to a list.  Then a user can manually purge them. ","version":null,"tagName":"h2"},{"title":"WLX","type":0,"sectionRef":"#","url":"/wlx-docs/docs/Reference/WLX/","content":"","keywords":"","version":null},{"title":"ProcessString‚Äã","type":1,"pageTitle":"WLX","url":"/wlx-docs/docs/Reference/WLX/#processstring","content":" Accepts a string with a WLX code and returns held Wolfram Expression  ProcessString[string_String, opts___] _Hold   where opts are following  &quot;Localize&quot; -&gt; _Bool specifies if lexical scoping of symbols defined inside WLX code fragment is needed (False by default)  ","version":null,"tagName":"h2"},{"title":"ToStringRiffle‚Äã","type":1,"pageTitle":"WLX","url":"/wlx-docs/docs/Reference/WLX/#tostringriffle","content":" Applies ToString to each element of a list and concats them with \\n delimiter  ToStringRiffle[any_ | any_List] _String  ","version":null,"tagName":"h2"},{"title":"WLJSTransport","type":0,"sectionRef":"#","url":"/wlx-docs/docs/Reference/Misc/WLJSTransport","content":"","keywords":"","version":null},{"title":"WLJSTransportScript‚Äã","type":1,"pageTitle":"WLJSTransport","url":"/wlx-docs/docs/Reference/Misc/WLJSTransport#wljstransportscript","content":" A helper function to set up a WebSocket connection to a server from a page. It should be placed and executed in the head section of a page  WLJSTransportScript[opts__] __String   There are several options  &quot;Port&quot; -&gt; _Integer (required) specifies a port of WebSocket server&quot;Event&quot; -&gt; _String an string identifier of an arbitrary EventObject on a server. Once connection established it will fire an event with &quot;Connected&quot; topic or pattern.  ","version":null,"tagName":"h2"},{"title":"Example‚Äã","type":1,"pageTitle":"WLJSTransport","url":"/wlx-docs/docs/Reference/Misc/WLJSTransport#example","content":" In the header section of your page, put this line  &lt;head&gt; ... &lt;WLJSTransportScript Port={yourPort}/&gt; &lt;/head&gt;   ","version":null,"tagName":"h3"},{"title":"WLJSTransportHandler‚Äã","type":1,"pageTitle":"WLJSTransport","url":"/wlx-docs/docs/Reference/Misc/WLJSTransport#wljstransporthandler","content":" A handler function for WebSocketHandler transport, that evaluates the requests from an WL interpreter running on client's side and provides features of symbols tracking.  WLJSTransportHandler   an entry point for evaluation requests, connect it to your chain of handlers as follows  ws = WebSocketHandler[] ws[&quot;MessageHandler&quot;, &quot;Evaluate&quot;] = Function[True] -&gt; WLJSTransportHandler   ","version":null,"tagName":"h2"},{"title":"Symbols tracking‚Äã","type":1,"pageTitle":"WLJSTransport","url":"/wlx-docs/docs/Reference/Misc/WLJSTransport#symbols-tracking","content":" To use this feature one need to specify a few more down-values  WLJSTransportHandler[&quot;AddTracking&quot;] = Function[{symbol, name, cli, callback}, Print[&quot;Add tracking... for &quot;&lt;&gt;name]; Experimental`ValueFunction[Unevaluated[symbol]] = Function[{y,x}, callback[cli, x]]; , HoldFirst] WLJSTransportHandler[&quot;GetSymbol&quot;] = Function[{expr, client, callback}, Print[&quot;Evaluating the desired symbol on the Kernel&quot;]; callback[expr // ReleaseHold]; ]   After that you can freely use Offload to dynamically bind symbols from server to pages.  ","version":null,"tagName":"h3"},{"title":"$Client‚Äã","type":1,"pageTitle":"WLJSTransport","url":"/wlx-docs/docs/Reference/Misc/WLJSTransport#client","content":" A global object, that specifies a connected client  ","version":null,"tagName":"h2"},{"title":"WLJSTransportSend‚Äã","type":1,"pageTitle":"WLJSTransport","url":"/wlx-docs/docs/Reference/Misc/WLJSTransport#wljstransportsend","content":" Submits an arbitrary WL expression to WL interpreter running in a browser using WebSockets  WLJSTransportSend[expr_, client_] _   A set of expression possible to be evaluated depends on WLJS Interpreter, its imported libraries and defined function on a page as well.  An identifier of a client can be retrieved using global symbol $Client in the context of fired &quot;Connected&quot; (see WLJSTransportScript Event) event or other events from buttons or other UI elements.  ","version":null,"tagName":"h2"},{"title":"Example‚Äã","type":1,"pageTitle":"WLJSTransport","url":"/wlx-docs/docs/Reference/Misc/WLJSTransport#example-1","content":" Once you know a connected client using $Client try to evaluate  WLJSTransportSend[Alert[&quot;Hello World&quot;], client]   ","version":null,"tagName":"h3"},{"title":"Offload‚Äã","type":1,"pageTitle":"WLJSTransport","url":"/wlx-docs/docs/Reference/Misc/WLJSTransport#offload","content":" A key-expression with HoldFirst attribute, that holds an expression to be interpreted on browser's side  Offload[expr_] _   Usually comes handy with automatic symbol binding between server and client, since an unknown symbol for a client is requested from server and then, interpreter subscribes for any changes of it.  ","version":null,"tagName":"h2"},{"title":"Example‚Äã","type":1,"pageTitle":"WLJSTransport","url":"/wlx-docs/docs/Reference/Misc/WLJSTransport#example-2","content":" Prepare your page and server as its shown in guide dynamics, attach symbols tracking as mentioned in WLJSTransportHandler and then  App.wlx pts = {{0,0}}; Graph = Graphics[Point[Offload @ pts], PlotRange -&gt; {{-1,1}, {-1,1}}]; task = SessionSubmit[ScheduledTask[pts = Append[pts, Last[pts] + 0.25 RandomReal[{-1,1}, 2]], Quantity[0.3, &quot;Seconds&quot;]]]; &lt;div class=&quot;mx-auto max-w-7xl py-6 sm:px-6 lg:px-8&quot;&gt; &lt;WLJS&gt;&lt;Graph/&gt;&lt;/WLJS&gt; &lt;/div&gt;   caution Created task will continue to run in the background. One need to detect closed connection and remove in manually. See tutorials.  ","version":null,"tagName":"h3"},{"title":"server‚Äã","type":1,"pageTitle":"WLJSTransport","url":"/wlx-docs/docs/Reference/Misc/WLJSTransport#server","content":" A global Javascript object that represents server and created by WLJSTransportScriptThere are several methods available for communication  ","version":null,"tagName":"h2"},{"title":".socket‚Äã","type":1,"pageTitle":"WLJSTransport","url":"/wlx-docs/docs/Reference/Misc/WLJSTransport#socket","content":" A connected WebSocket object  ","version":null,"tagName":"h3"},{"title":".send(message)‚Äã","type":1,"pageTitle":"WLJSTransport","url":"/wlx-docs/docs/Reference/Misc/WLJSTransport#sendmessage","content":" Send a message for evaluation (async)  server.send('Echo[&quot;Hi from sockets!&quot;]')   ","version":null,"tagName":"h3"},{"title":".emitt(uid, message, topic='Default')‚Äã","type":1,"pageTitle":"WLJSTransport","url":"/wlx-docs/docs/Reference/Misc/WLJSTransport#emittuid-message-topicdefault","content":" Emits an event on server's side with a given string identifier of EventObject. To capture an event one have to subscribe to it using  server.emitt('uid', '1+1', 'Topic');   and on server's side  EventHandler[&quot;uid&quot;, {&quot;Topic&quot; -&gt; Function[data, Print[data]; ]}]   or an omni listener  EventHandler[&quot;uid&quot;, Function[data, Print[data]; ]]   ","version":null,"tagName":"h3"},{"title":".ask(message)‚Äã","type":1,"pageTitle":"WLJSTransport","url":"/wlx-docs/docs/Reference/Misc/WLJSTransport#askmessage","content":" Asynchronously evaluates a message on a server and returns Promise object  const data = await server.ask('RandomReal[{-1,1}, 100]'); const result = await interpretate(data, {}); console.log(result);  ","version":null,"tagName":"h3"},{"title":"WLJS","type":0,"sectionRef":"#","url":"/wlx-docs/docs/Reference/WLX/WLJS","content":"","keywords":"","version":null},{"title":"WLJSHeader‚Äã","type":1,"pageTitle":"WLJS","url":"/wlx-docs/docs/Reference/WLX/WLJS#wljsheader","content":" A helper function to add javascript modules to the head of a page  WLJSHeader[opts__] _String   where a single option is accepted  &quot;List&quot; a list of urls to Javascript files  ","version":null,"tagName":"h2"},{"title":"Example‚Äã","type":1,"pageTitle":"WLJS","url":"/wlx-docs/docs/Reference/WLX/WLJS#example","content":" Put this line in your head section on a page  ExtensionsJS = { &quot;url_to_js.js&quot;, &quot;url_to_js.js&quot; }; &lt;head&gt; ... &lt;WLJSHeader List={ExtensionsJS}/&gt; &lt;head&gt;   ","version":null,"tagName":"h3"},{"title":"WLJS‚Äã","type":1,"pageTitle":"WLJS","url":"/wlx-docs/docs/Reference/WLX/WLJS#wljs","content":" A function to embed Wolfram Language code on a static page. It also creates a corresponding div element on a page, where it is placed for a graphical or text output. Once loaded it starts local WL interpreter running in the browser  WLJS[expr_] _String   an expr can be anything interpretable by WLJS Interpreter and its libraries.  ","version":null,"tagName":"h2"},{"title":"Example‚Äã","type":1,"pageTitle":"WLJS","url":"/wlx-docs/docs/Reference/WLX/WLJS#example-1","content":" Prepare your server as its shown in a guide interpeter and  P = Plot[Sin[x], {x, -2Pi, 2Pi}]; &lt;div class=&quot;mx-auto max-w-7xl py-6 sm:px-6 lg:px-8&quot;&gt; &lt;WLJS&gt;&lt;P/&gt;&lt;/WLJS&gt; &lt;/div&gt;  ","version":null,"tagName":"h3"},{"title":"Promise","type":0,"sectionRef":"#","url":"/wlx-docs/docs/Reference/Misc/Promise","content":"","keywords":"","version":null},{"title":"Promise‚Äã","type":1,"pageTitle":"Promise","url":"/wlx-docs/docs/Reference/Misc/Promise#promise","content":" A constructor and also representation of EventObject which can be fired only once (aka resolved) and even before a corresponding handler is attached  Promise[] _Promise (* constructor *)   To resolve or reject a promise - use EventFire  EventFire[p_Promise, Resolve | Reject, data_]   ","version":null,"tagName":"h2"},{"title":"Then‚Äã","type":1,"pageTitle":"Promise","url":"/wlx-docs/docs/Reference/Misc/Promise#then","content":" An expression for asynchronous subscribing to promise resolution or rejection  Then[p_Promise | _List | _, resolve_] Then[p_Promise | _List | _, resolve_, reject_]   where resolve and reject are any arbitrary functions. This is non-blocking function.  info The key difference between EventHandler and Then is that Then can even be applied to already resolved Promise object (after it was fired), which will cause an immediate evaluation of resolve or reject functions.  Being applied to a List of _Promise objects it will wait until all of them are resolved before evaluating resolve function.  Any Wolfram Expressions, which is not a List or Promise counts as resolved.  ","version":null,"tagName":"h2"},{"title":"Example‚Äã","type":1,"pageTitle":"Promise","url":"/wlx-docs/docs/Reference/Misc/Promise#example","content":" Let's try with a multiple promise events  p1 = Promise[]; p2 = Promise[]; SetTimeout[EventFire[p1, Resolve, Null], 1000]; SetTimeout[EventFire[p2, Resolve, Null], 1500]; Then[{p1,p2,Null}, Function[Null, Echo[&quot;Resolved!&quot;]; ]];   Here Null as a last element of a list was used just for demonstration purposes. It can also be any non _Promise | _List expression.  ","version":null,"tagName":"h3"},{"title":"WaitAll‚Äã","type":1,"pageTitle":"Promise","url":"/wlx-docs/docs/Reference/Misc/Promise#waitall","content":" A synchronous blocking function to wait until a promise has resolved and returns the result  WaitAll[p_Promise] _   There is a timeout of 5 seconds, then $Failed is returned.  caution Be careful while using this. Avoid to use in SessionSubmit, BackgroundTask and other interrupting the main loop subroutines. If your promise resolution does depend on TCP socket message, it will never be resolved properly, since all subroutines blocks TCP sockets and other external services. ","version":null,"tagName":"h2"},{"title":"Importer","type":0,"sectionRef":"#","url":"/wlx-docs/docs/Reference/WLX/Importer","content":"","keywords":"","version":null},{"title":"ImportComponent‚Äã","type":1,"pageTitle":"Importer","url":"/wlx-docs/docs/Reference/WLX/Importer#importcomponent","content":" Is used to import WLX files as Wolfram Expressions  ImportComponent[path_String, opts___] ___   an imported file is processed using [[Reference/WLX/WLX#ProcessString]] immediately. The result can be cached and then used without costs of parsing.  ","version":null,"tagName":"h2"},{"title":"path‚Äã","type":1,"pageTitle":"Importer","url":"/wlx-docs/docs/Reference/WLX/Importer#path","content":" A universal path resolver is used, it is indifferent for the way how you write the path to a file in Unix- or Windows-style.  Nested folders‚Äã  When you import a component inside other component, an automatic guess happens if the given file is located in the same folder or an absolute path is used, i.e.  Root Main.wlxLabel Label.wlxComponents Someother.wlx  and  Main.wlx ... ... = ImportComponent[&quot;Label/Label.wlx&quot;]   Label/Label.wlx ... ... = ImportComponent[&quot;Components/Someother.wlx&quot;]   are valid.  ","version":null,"tagName":"h3"},{"title":"opts‚Äã","type":1,"pageTitle":"Importer","url":"/wlx-docs/docs/Reference/WLX/Importer#opts","content":" The following options are valid  &quot;Localize&quot; -&gt; _Bool is the same as for ProcessString. Default value is True.  ","version":null,"tagName":"h3"},{"title":"Notes on SetDelayed and Set‚Äã","type":1,"pageTitle":"Importer","url":"/wlx-docs/docs/Reference/WLX/Importer#notes-on-setdelayed-and-set","content":" Normally once component imported it can be assigned to a symbol. However, SetDelayed still imports a component, but keeps an parsed expression unevaluated (Hold), i.e.  Component := ImportComponent[&quot;Component.wlx&quot;]; &lt;Component Option={Whatever}/&gt;   where  Component.wlx With[{Opt = $Options[&quot;Option&quot;]}, &lt;h1&gt;&lt;Opt/&gt;&lt;/h1&gt; ]   While the typical case for Set operator is when a component returns a function, i.e.  Component = ImportComponent[&quot;Component.wlx&quot;]; &lt;Component Option={Whatever}/&gt;   and  Component.wlx Component[OptionsPattern[]] := With[{Opt = OptionValue[&quot;Option&quot;]}, &lt;h1&gt;&lt;Opt/&gt;&lt;/h1&gt; ] Component   ","version":null,"tagName":"h3"},{"title":"$Options‚Äã","type":1,"pageTitle":"Importer","url":"/wlx-docs/docs/Reference/WLX/Importer#options","content":" Is a global symbol that provides access to all passed XML attributes to a WLX component  $Options _Association   ","version":null,"tagName":"h2"},{"title":"$FirstChild‚Äã","type":1,"pageTitle":"Importer","url":"/wlx-docs/docs/Reference/WLX/Importer#firstchild","content":" A global symbol that provides access to the first passed child (as XML children) or an argument (like in normal WL) to a WLX component  $FirstChild _   ","version":null,"tagName":"h2"},{"title":"$Children‚Äã","type":1,"pageTitle":"Importer","url":"/wlx-docs/docs/Reference/WLX/Importer#children","content":" A global symbol that provides access to all passed children (as XML children) or arguments (like in normal WL) to a WLX component  $Children _List   ","version":null,"tagName":"h2"},{"title":"CacheControl‚Äã","type":1,"pageTitle":"Importer","url":"/wlx-docs/docs/Reference/WLX/Importer#cachecontrol","content":" Enables or disables caching for imported components  JerryI`WLX`Importer`Private`CacheControl[interval_String | True | False]   The possible values for a time-interval are  &quot;Hour&quot;&quot;Minute&quot; ","version":null,"tagName":"h2"},{"title":"Events","type":0,"sectionRef":"#","url":"/wlx-docs/docs/Reference/Misc/Events","content":"","keywords":"","version":null},{"title":"EventObject‚Äã","type":1,"pageTitle":"Events","url":"/wlx-docs/docs/Reference/Misc/Events#eventobject","content":" A complete representation of event-object with its initial data and possible decorative representation  EventObject[&lt;|&quot;Id&quot;-&gt;_String, &quot;Initial&quot;-&gt;_, &quot;View&quot;-&gt;_|&gt;]   Actual binding happens with only &quot;Id&quot; field, therefore a string equivalent is also valid to use  _String   ","version":null,"tagName":"h2"},{"title":"\"Initial\"‚Äã","type":1,"pageTitle":"Events","url":"/wlx-docs/docs/Reference/Misc/Events#initial","content":" Stores initial data, which makes sense if an event object was produced by some sliders, toggle switches or other UI elements.  If an event was joined with other event, &quot;Initial&quot; data will be merged as well depending on its original structure.  If an event object is used in EventFire with no data provided, &quot;Initial&quot; field will be used instead as a payload.  ","version":null,"tagName":"h3"},{"title":"\"View\"‚Äã","type":1,"pageTitle":"Events","url":"/wlx-docs/docs/Reference/Misc/Events#view","content":" An implementation depends on the executing environment. On WLX pages, or inside notebook this field will represent how an event object will be displayed. Usually if it has been generated by some UI component, a button or a slider is displayed on output, that fires this event remotely using a provided &quot;Id&quot;.  ","version":null,"tagName":"h3"},{"title":"Inheritable properties‚Äã","type":1,"pageTitle":"Events","url":"/wlx-docs/docs/Reference/Misc/Events#inheritable-properties","content":" There is only a single field &quot;Initial&quot; that can be merged or copied under EventClone and Join or EventJoin operations.  ","version":null,"tagName":"h3"},{"title":"Non-inheritable properties‚Äã","type":1,"pageTitle":"Events","url":"/wlx-docs/docs/Reference/Misc/Events#non-inheritable-properties","content":" &quot;Id&quot;, &quot;View&quot; cannot be copied under EventJoin, EventClone and Join operations.  ","version":null,"tagName":"h3"},{"title":"EventHandler‚Äã","type":1,"pageTitle":"Events","url":"/wlx-docs/docs/Reference/Misc/Events#eventhandler","content":" Binds an event object represented as a string or EventObject or anything compatible with this type to a single or multiple handling functions (multiple - only if patterns do not intersect)  EventHandler[ev_String | _EventObject, {handlers___Rule | handlers___RuleDelayed}]   where handlers is a sequence of rules (straight or delayed), which are applied to any incoming message. Each rule represents a normal WL pattern to mach a message generated by EventFire.  There is a simpler version as well, which is indifferent to patterns  EventHandler[ev_String | _EventObject, handler_]   which is effectively  EventHandler[ev_String | _EventObject, {_ -&gt; handler_}]   warning Only a single handler function can be assign to an event object per pattern. If you need multiple handlers (chain) to be assigned to the same event and pattern - clone your event firstly using EventClone  Return value‚Äã  It is optional, but any handler can return any non-Null expression, which will be presented as a return value of EventFire expression.  ","version":null,"tagName":"h2"},{"title":"Example‚Äã","type":1,"pageTitle":"Events","url":"/wlx-docs/docs/Reference/Misc/Events#example","content":" The simples case scenario  EventHandler[&quot;ev&quot;, Print]; EventFire[&quot;ev&quot;, &quot;Hello World!&quot;];   or using different patterns  EventHandler[&quot;ev&quot;, { &quot;Case 1&quot; -&gt; Print, &quot;Case 2&quot; -&gt; Echo, any_String :&gt; Function[data, Echo[StringJoin[&quot;Undefined case: &quot;, any]]] }]; EventFire[&quot;ev&quot;, &quot;Case 1&quot;, &quot;Hello World!&quot;]; EventFire[&quot;ev&quot;, &quot;Case 2&quot;, &quot;Hello World!&quot;]; EventFire[&quot;ev&quot;, &quot;Case 3&quot;, &quot;Hello World!&quot;];   note Patterns do not have to be strings only. Any Wolfram Expression is valid  ","version":null,"tagName":"h3"},{"title":"EventClone‚Äã","type":1,"pageTitle":"Events","url":"/wlx-docs/docs/Reference/Misc/Events#eventclone","content":" Clones event object and returns a new one, keeping all previous assigned handlers on another copy of it  EventClone[ev_String | _EventObject] _EventObject   Multiple calls on the same ev makes a chain of new event objects connected to it. Once EventFire is called on ev, it will sequentially fire all cloned events in a chain.  ","version":null,"tagName":"h2"},{"title":"EventRemove‚Äã","type":1,"pageTitle":"Events","url":"/wlx-docs/docs/Reference/Misc/Events#eventremove","content":" Removes all handlers from a given event object  EventRemove[ev_String | _EventObject]   or  Delete[ev_EventObject]   is also valid. Removing a cloned event only removes handlers from the cloned event object  ","version":null,"tagName":"h2"},{"title":"EventJoin‚Äã","type":1,"pageTitle":"Events","url":"/wlx-docs/docs/Reference/Misc/Events#eventjoin","content":" Joins two independent events into a new one merging their &quot;Initial&quot; values as well  EventJoin[ev__String | __EventObject] _EventObject   however  Join[ev__EventObject] _EventObject   is also valid.  ","version":null,"tagName":"h2"},{"title":"EventFire‚Äã","type":1,"pageTitle":"Events","url":"/wlx-docs/docs/Reference/Misc/Events#eventfire","content":" Fires an event with provided data and pattern  EventFire[ev_String | _EventObject, data_] _ EventFire[ev_String | _EventObject, pattern_, data_] _   or for a complete event object representation  EventFire[ev_EventObject] _   it takes &quot;Initial&quot; field as data. Effectively if pattern is not provided &quot;Default&quot; pattern is used instead. ","version":null,"tagName":"h2"},{"title":"Events","type":0,"sectionRef":"#","url":"/wlx-docs/docs/Event system/basics","content":"","keywords":"","version":null},{"title":"Thumb rule‚Äã","type":1,"pageTitle":"Events","url":"/wlx-docs/docs/Event system/basics#thumb-rule","content":" One event-object - one handler function  ev = EventObject[&lt;|&quot;Id&quot;-&gt;&quot;evid&quot;|&gt;] EventHandler[ev, Print]   i.e.    And then to fire  EventFire[ev, &quot;Hello World!&quot;];   In order to remove handler from event object use  Delete[ev]   or more universal  EventRemove[ev]   where it deletes a handler function, but not an EventObject.  tip To assign more event handlers, you need to clone an event object or use different pattern on the same event object (see Pattern matching).  ","version":null,"tagName":"h2"},{"title":"String equivalent‚Äã","type":1,"pageTitle":"Events","url":"/wlx-docs/docs/Event system/basics#string-equivalent","content":" The actual binding is done only by &quot;Id&quot; field, therefore, one can omit EventObject head  ev = &quot;evid&quot;; EventHandler[ev, Print]   is the same as  ev = EventObject[&lt;|&quot;Id&quot;-&gt;&quot;evid&quot;|&gt;] EventHandler[ev, Print]   ","version":null,"tagName":"h3"},{"title":"Pattern matching‚Äã","type":1,"pageTitle":"Events","url":"/wlx-docs/docs/Event system/basics#pattern-matching","content":" In general an event entity can carry an additional information using Wolfram Language Patterns. It can distribute messages across different handler functions based on type of event fired (or its topic lets say). Using regular syntax for replacing patterns with Rule and RuleDelayed one can write a much more detailed handler function  EventHandler[&quot;evid&quot;, { &quot;Topic&quot; -&gt; Function[data, Echo[&quot;Topic::&quot;]; Echo[data]; ], any_String :&gt; Function[data, Echo[StringJoin[any, &quot;::&quot;]]; Echo[data]; ] }];   And to fire an event on a specific pattern - add extra argument to the middle of a sequence  EventFire[&quot;evid&quot;, &quot;Topic&quot;, &quot;Hi!&quot;]; EventFire[&quot;evid&quot;, &quot;Whatever&quot;, &quot;Hi!&quot;];   However, it is not limited to String  EventHandler[&quot;evid&quot;, { _Abrakadabra -&gt; Function[Null, Echo[&quot;Got it!&quot;]; ], _ -&gt; Function[Null, Echo[&quot;Wrong one&quot;]; ] }]; EventFire[&quot;evid&quot;, Abrakadabra[], Null]   One should note, that effectively those are the same records  EventHandler[ev, Print] EventHandler[ev, {_ -&gt; Print}]   while  EventFire[ev, data] EventFire[ev, &quot;Default&quot;, data]   are also the same.  ","version":null,"tagName":"h2"},{"title":"Cloning events‚Äã","type":1,"pageTitle":"Events","url":"/wlx-docs/docs/Event system/basics#cloning-events","content":" In the previous examples we had only one handler function per pattern. If you want more, there is a way to clone an EventObject or its string equivalent  ev = EventObject[&lt;|&quot;Id&quot;-&gt;&quot;evid&quot;|&gt;] (* first handler *) EventHandler[ev, Print]; (* second handler *) cloned = EventClone[ev]; EventHandler[cloned, Print];   What it does, it creates something like an event router subscribed to the original event-object, a router, then, is populated by the two new event-objects    Anything you do with cloned event will not affect the original entitiy  Delete[cloned] or EventRemove[cloned]   info Cloned object inherits all properties (i.e. initial data), that the original object has.  tip If you are sure, that two EventHandler function does not intersect with their patterns attached to the same event-object, there is no need in cloning, i.e. EventHandler[ev, { &quot;Pattern 1&quot; -&gt; func1 }]; EventHandler[ev, { &quot;Pattern 2&quot; -&gt; func2 }]; EventFire[ev, ..., data]; is valid. Patterns will be merged.  ","version":null,"tagName":"h2"},{"title":"Return value‚Äã","type":1,"pageTitle":"Events","url":"/wlx-docs/docs/Event system/basics#return-value","content":" Each handling function can return some value back, that again carries extra information  EventHandler[ev, Function[Null, Now ]]; EventFire[ev, Null] // Echo   an Echo from the last line will print current date. The same can be done with a chain of cloned events, i.e.  EventHandler[ev, Function[Null, Now ]]; EventHandler[ev // EventClone, Function[Null, Now ]]; EventHandler[ev // EventClone, Function[Null, Now ]]; EventFire[ev, Null] // Echo   The returned value will be a list of three semi-identical dates.  tip Use return values to provide Promise objects, when one or more of your chained handlers asks the side, which fired a chain, to wait for some deferred event be happen (see Then).  ","version":null,"tagName":"h2"},{"title":"Merging‚Äã","type":1,"pageTitle":"Events","url":"/wlx-docs/docs/Event system/basics#merging","content":" For example you want to update the state of something based on two events, that may happen independently, then use  ev1 = EventObject[&lt;|&quot;Id&quot;-&gt;&quot;evid1&quot;|&gt;] ev2 = EventObject[&lt;|&quot;Id&quot;-&gt;&quot;evid2&quot;|&gt;] joined = Join[ev1, ev2]   tip You do not have to clone your events before joining them, since it does it automatically keeping all other connections intact    ","version":null,"tagName":"h2"},{"title":"Properties‚Äã","type":1,"pageTitle":"Events","url":"/wlx-docs/docs/Event system/basics#properties","content":" There is a possibility to carry an additional keys wrapped inside EventObject. By its nature this is not a classical object in the sense of OOP, since the handler function has no access to the their properties and only Id field is stored in global a memory.  ","version":null,"tagName":"h2"},{"title":"Inheritable‚Äã","type":1,"pageTitle":"Events","url":"/wlx-docs/docs/Event system/basics#inheritable","content":" There is a property &quot;Initial&quot;, that specifies the initial value of the data shipped when the event is fired, when you apply Join or EventClone the final initial conditions will be merged from the different event objects or just copied  ev1 = EventObject[&lt;|&quot;Id&quot;-&gt;&quot;ev1&quot;, &quot;Initial&quot;-&gt;&lt;|&quot;x&quot;-&gt;1|&gt;|&gt;] ev2 = EventObject[&lt;|&quot;Id&quot;-&gt;&quot;ev1&quot;, &quot;Initial&quot;-&gt;&lt;|&quot;y&quot;-&gt;2|&gt;|&gt;] Join[ev1, ev2]   the result will be  EventObject[&lt;|&quot;Id&quot;-&gt;&quot;generatedId&quot;, &quot;Initial&quot;-&gt;&lt;|&quot;x&quot;-&gt;1, &quot;y&quot;-&gt;2|&gt;|&gt;]   What also makes field &quot;Initial&quot; so special is that it can be automatically substituted to EventFire method, when no other data is provided  EventFire[ev]   is effectively  EventFire[ev, ev[[1]][&quot;Initial&quot;]]   ","version":null,"tagName":"h3"},{"title":"Non-inheritable‚Äã","type":1,"pageTitle":"Events","url":"/wlx-docs/docs/Event system/basics#non-inheritable","content":" A very useful property, that comes handy when making GUI elements &quot;View&quot;  EventObject[&lt;|&quot;Id&quot;-&gt;&quot;evid&quot;, &quot;View&quot;-&gt;Graphics3D[Sphere[]]|&gt;]   it acts only when the object is printed to the output cell or displayed on a page (see WLJS), then, we will see Graphics3D output instead of EventObject.  ","version":null,"tagName":"h3"},{"title":"Integration with server / client via WebSockets‚Äã","type":1,"pageTitle":"Events","url":"/wlx-docs/docs/Event system/basics#integration-with-server--client-via-websockets","content":" A framework of WLJSTransport redirects calls from Javascript code to event system as well. A global server object provides a corresponding method  server.emitt('evid', 'message') //or server.emitt('evid', 'message', 'pattern')   and on server's side one can do as usual  EventHandler[&quot;evid&quot;, Print]  ","version":null,"tagName":"h3"},{"title":"Asteroids","type":0,"sectionRef":"#","url":"/wlx-docs/docs/WLX/examples/asteroids","content":"","keywords":"","version":null},{"title":"App instances‚Äã","type":1,"pageTitle":"Asteroids","url":"/wlx-docs/docs/WLX/examples/asteroids#app-instances","content":" For each window a separate instance of app is generated  App[OptionsPattern[]] := With[{ globalControls = OptionValue[&quot;Controls&quot;], localControls = CreateUUID[] }, With[{ PlottingDevice = create[globalControls] }, &lt;div class=&quot;divide-y divide-gray-200 max-w-lg overflow-hidden rounded-lg bg-white shadow&quot;&gt; &lt;div class=&quot;px-2 py-2&quot;&gt; &lt;WLJS&gt; &lt;PlottingDevice/&gt; &lt;/WLJS&gt; &lt;/div&gt; &lt;/div&gt; ] ]   where create allocates symbols for players targets, life meter and etc...  create[controls_] := Module[{ target = {0,-1}, life = 2., score = 0, listener, enemies = {}, projectiles = {}, positions = {}, gameEvents, delay = 5 }, gameEvents = EventClone[&quot;game&quot;]; EventHandler[controls, { &quot;Destroy&quot; -&gt; Function[cli, Echo[&quot;Widget removed!&quot;]; EventFire[&quot;game&quot;, &quot;Remove player&quot;, &lt;|&quot;Client&quot;-&gt;cli|&gt;]; EventRemove[gameEvents]; checkTask; ], &quot;Connected&quot; -&gt; Function[cli, EventHandler[gameEvents, { UpdatePositions -&gt; Function[Null, positions = #[&quot;Target&quot;] &amp;/@ Values[players]; ], UpdateProjectiles -&gt; Function[Null, projectiles = proximitySort[projectiles, #[[1]] &amp;/@ globalProjectiles]; ], UpdateEnemies -&gt; Function[Null, enemies = proximitySort[enemies, #[[1]] &amp;/@ globalEnemies]; If[life &lt; 0, Close[cli]; ]; ] }]; EventFire[&quot;game&quot;, &quot;Add player&quot;, &lt;|&quot;Client&quot;-&gt;cli, &quot;Target&quot;:&gt;target, &quot;Life&quot;:&gt;life|&gt;]; checkTask; ] }]; listener = {White, EventHandler[Rectangle[{-10, -10}, {10,10}], { &quot;mousemove&quot;-&gt;Function[xy, target = xy; EventFire[&quot;game&quot;, UpdatePositions, Null]; delay -= 1; If[delay &lt; 0, globalProjectiles = Append[globalProjectiles, Projectile[xy + {0, 0.05}, {RandomReal[{-0.03,0.03}], 0.15}, 2]]; delay = 4; ]; ] }]}; Graphics[{ listener, {Green, Rectangle[{1,-1}, {1.1, Offload[life] - 1}]}, {Blue, PointSize[0.1], Point @ Offload @ enemies}, RGBColor[1.0 - 0.1764, 1.0 - 0.8313, 1.0 - 0.74901], Point[Offload @ projectiles], RGBColor[0.1764, 0.8313, 0.74901], PointSize[0.05], Point[Offload @ positions] }, TransitionDuration-&gt;1, TransitionType-&gt;&quot;Linear&quot;, PlotRange-&gt;{{-1,1}, {-1,1}}] ];   Players position is stored in target symbol, which is shared with a global variable players using global event &quot;New player&quot;. On every change a global event with a topic (or pattern) UpdatePositions is fired, that forces all connected player to reload the positions of all connected players. The current client is also subscribed to the same global event.  For depicting enemies, projectiles and all players Dynamic symbols are used. However, there is a limitation, that for one symbol only one subscribed client is allowed. Therefore, for each client a local symbols such as enemies, projectiles and positions are allocated, to which all data is transferred once an update has been fired.  ","version":null,"tagName":"h2"},{"title":"Limitations of graphical output‚Äã","type":1,"pageTitle":"Asteroids","url":"/wlx-docs/docs/WLX/examples/asteroids#limitations-of-graphical-output","content":" There is a limitation in this implementation, that all local symbols for moving objects are arrays and are plotted in a very primitive way as  {Blue, PointSize[0.1], Point @ Offload @ enemies},...   Since enemies length is a variable, it can extend and shrink its size based on number of alive enemies. This leads to a problem, that graphics library draw them as SVG objects. Then when a new enemy added or removed, it does not know, which one is which and just adds or removes the last one, while the all previous are considered to be the same with a new position read from a new array. It leads to serious problems if interpolation is used, i.e. when order of enemies is shifted in an array, all SVG objects jump and flicker. This is a reason, why TransitionDuration is set to 1, to get rid of interpolation mostly.  A better approach would be to threat them as individual graphics object on server as well. And dynamically add or remove them from the screen. So far this feature is still in development, but on can still use available methods of such as Call actions on a page to assign Javascript function to it.  ","version":null,"tagName":"h3"},{"title":"Server's cycle‚Äã","type":1,"pageTitle":"Asteroids","url":"/wlx-docs/docs/WLX/examples/asteroids#servers-cycle","content":" Here is is rather simple, there is a single continuous async task running in the background  calculate := ( time += 0.1; calculateProjectile[]; calculateEnemies[]; spawnEnemies[]; )   for each calculation cycle it fires a global event  globalEnemies = {}; calculateEnemies[] := With[{}, globalEnemies = calculateEnemies /@ globalEnemies; EventFire[&quot;game&quot;, UpdateEnemies, Null]; ]  ","version":null,"tagName":"h2"},{"title":"File explorer & Plotter","type":0,"sectionRef":"#","url":"/wlx-docs/docs/WLX/examples/fileexplorer","content":"","keywords":"","version":null},{"title":"Action‚Äã","type":1,"pageTitle":"File explorer & Plotter","url":"/wlx-docs/docs/WLX/examples/fileexplorer#action","content":" To get the most of your attention we would like to start with a short demo of this application    To run this demo  wolframscript -f Examples/Explorer/Explorer.wls   ","version":null,"tagName":"h2"},{"title":"Description‚Äã","type":1,"pageTitle":"File explorer & Plotter","url":"/wlx-docs/docs/WLX/examples/fileexplorer#description","content":" The first example uses only HTTP server and static mode of WLJS Interpreter. The project structure is following  Explorer/ public directory Views/ None.wlx representation of non-existing file Image.wlx display an image Editor.wlx display a plain text Plot.wlx plot any data Directory.wlx\tshow directory list Components/ Head.wlx header component Logo.wlx logo of WLX in svg Label.wlx wrapper for labels Breadcrumbs.wlx\tdisplays path in a nav bar List.wlx forms a list of items example data/ directory with example data to open App.wlx main layout of an app Explorer.wls main startup file   A file explorer takes a path provided in URL and use it relatively to the Explorer folder to depict the content  Explorer.wls ... App = ImportComponent[&quot;App.wlx&quot;]; FileRequestQ[request_] := (!MissingQ[request[&quot;Query&quot;][&quot;file&quot;]]) http = HTTPHandler[]; http[&quot;MessageHandler&quot;, &quot;File&quot;] = FileRequestQ -&gt; ImportFile http[&quot;MessageHandler&quot;, &quot;Index&quot;] = AssocMatchQ[&lt;|&quot;Method&quot; -&gt; &quot;GET&quot;|&gt;] -&gt; App ...   It is quite funny way of using URLs, since usually the path is provided by a parameter, but not as an actual url relative to the hostname. To get the &quot;real&quot; file it uses a bypass provided by FileRequestQ, that check if file=true parameter is presented.  Any other URLs are passed to App.wlx, where it check the content and then chooses the corresponding view-component to display the data  App.wlx dir := ImportComponent[&quot;Views/Directory.wlx&quot;]; editor := ImportComponent[&quot;Views/Editor.wlx&quot;]; image := ImportComponent[&quot;Views/Image.wlx&quot;]; plot := ImportComponent[&quot;Views/Plot.wlx&quot;]; none := ImportComponent[&quot;Views/None.wlx&quot;]; Breadcrumbs := ImportComponent[&quot;Components/Breadcrumbs.wlx&quot;]; (* /* view router */ *) Unprotect[ImageQ] ImageQ[path_String] := FileExistsQ[path] &amp;&amp; StringMatchQ[path, RegularExpression[&quot;.*\\\\.(png|jpg|svg|bmp|jpeg)$&quot;]] DatQ[path_String] := FileExistsQ[path] &amp;&amp; StringMatchQ[path, RegularExpression[&quot;.*\\\\.(dat|csv)$&quot;]] AnyQ[path_String] := FileExistsQ[path] View[path_?DirectoryQ] := (Print[&quot;Directory!&quot;]; dir[path] ); View[path_?ImageQ] := (Print[&quot;Image!&quot;]; image[path] ); View[path_?DatQ] := (Print[&quot;Data!&quot;]; plot[path] ); View[path_?AnyQ] := (Print[&quot;Editor!&quot;]; editor[path]); View[path_] := (Print[&quot;None!&quot;]; none[path] ); ...   For example a viewer for images looks like this  Views/Image.wlx URL = URLBuild[&lt;|&quot;Path&quot; -&gt; FileNameSplit[$FirstChild], &quot;Query&quot; -&gt; &lt;|&quot;file&quot; -&gt; True|&gt;|&gt;]; &lt;figure class=&quot;max-w-lg bg-gray-100&quot;&gt; &lt;img class=&quot;h-auto max-w-full rounded-lg&quot; src=&quot;/{URL}&quot; alt=&quot;image description&quot;/&gt; &lt;/figure&gt;   Easy, ha?  To plot something it is also quite intuitive - import the data and plot using WLJS  Views/Plot.wlx Data = Drop[Import[$FirstChild, &quot;TSV&quot;], 3]; PlottingDevice = With[{p = ListLinePlot[Data, PlotRange-&gt;Full, ImageSize-&gt;700]}, Insert[p, Controls-&gt;True, {2,-1}] ]; &lt;figure style=&quot;display: inline-block&quot;&gt; &lt;WLJS Class={&quot;h-auto max-w-full flex rounded-lg p-3 bg-gray-100&quot;}&gt; &lt;PlottingDevice/&gt; &lt;/WLJS&gt; &lt;figcaption class=&quot;text-center gap-x-4 min-w-0 mt-1 text-xs leading-5 text-gray-500&quot;&gt;Drag - pan, wheel - zoom&lt;/figcaption&gt; &lt;/figure&gt;   There is an abstraction PlottingDevice used for injecting an option Controls, that allows Graphics object use mouse to zoom and pan the graph (options of the standard ListLinePlot are protected by Wolfram Research ‚òπÔ∏è ). ","version":null,"tagName":"h2"},{"title":"Basics of syntax","type":0,"sectionRef":"#","url":"/wlx-docs/docs/WLX/basics","content":"","keywords":"","version":null},{"title":"Tags‚Äã","type":1,"pageTitle":"Basics of syntax","url":"/wlx-docs/docs/WLX/basics#tags","content":" It is easy to guess who is who  HTML tag &lt;div&gt;&lt;/div&gt; Wolfram Expression &lt;Div&gt;&lt;/Div&gt;   There is no¬†html¬†tags on Earth, that starts from the capital letter.  ","version":null,"tagName":"h2"},{"title":"Ownvalues and Downvalues‚Äã","type":1,"pageTitle":"Basics of syntax","url":"/wlx-docs/docs/WLX/basics#ownvalues-and-downvalues","content":" Those types of assignments are most commonly used in Wolfram Language. Thankfully HTML/XML tag syntax allows to make it clear, which one is called  TextString[Now]   &lt;TextString&gt; &lt;Now/&gt; &lt;/TextString&gt;   First child element is the first argument of a given function and etc.¬†Any self-closing tags represent an own-value of a symbol.  Any Number or String can be embedded as tag as well  &lt;Plus/&gt;&lt;1.0/&gt;&lt;1.0/&gt;&lt;/Plus&gt;   ","version":null,"tagName":"h2"},{"title":"Simple rules is the key‚Äã","type":1,"pageTitle":"Basics of syntax","url":"/wlx-docs/docs/WLX/basics#simple-rules-is-the-key","content":" There are certain rules you should sticked to in order to write a valid WLX  ","version":null,"tagName":"h2"},{"title":"Keep only one or zero root XML element‚Äã","type":1,"pageTitle":"Basics of syntax","url":"/wlx-docs/docs/WLX/basics#keep-only-one-or-zero-root-xml-element","content":" This implies that this one will be exported to the output, like in CompoundExpression  (* whatever WL code *) Var = &quot;Hello World!&quot;; &lt;body&gt; &lt;Var/&gt; &lt;/body&gt;   This is good üëçüèº  However it does not mean, you cannot have nested expressions  (* whatever WL code *) Var = &lt;h1&gt;Hello World!&lt;/h1&gt;; &lt;body&gt; &lt;Var/&gt; &lt;/body&gt;   This is also good üëçüèº  ","version":null,"tagName":"h3"},{"title":"Always close any XML tags‚Äã","type":1,"pageTitle":"Basics of syntax","url":"/wlx-docs/docs/WLX/basics#always-close-any-xml-tags","content":" Modern web-browsers are quite forgiving, when it comes to the syntax mistakes. All over the internet there is code like this  &lt;img src=&quot;http://...&quot;&gt;   This is wrong üëéüèº according to the convention of XML.  WLX parser decodes the whole tree of XML and WL and, then, reconstructs it from AST. Therefore, always close tags explicitly  &lt;img src=&quot;http://...&quot;/&gt;   Much better üëçüèº  tip Since WLX syntax is quite close to JSX, modern linters and syntax highlighting libraries can verify tags in WLX as well using JSX preset. Wolfram Expressions are quite hard to check, but in general, this comes very handy when you write a large script. Avoid using @, // and wrap comments like in C (* /* */ *) to reduce the number of warning from the JSX linter.  ","version":null,"tagName":"h3"},{"title":"Passing HTML attributes‚Äã","type":1,"pageTitle":"Basics of syntax","url":"/wlx-docs/docs/WLX/basics#passing-html-attributes","content":" This is a crucial thing, when it comes to a markup. To maintain sort of compatibility with a well-established Handlebars, JSX curly braces with double quotes are used  URL = &quot;https://upload.wikimedia.org/wikipedia/commons/7/70/Oftheunicorn.jpg&quot; &lt;img width=&quot;300&quot; src=&quot;{URL}&quot;/&gt;   Since this is anyway a string, you can use it as a template  URL = &quot;upload.wikimedia.org/wikipedia/commons/7/70/Oftheunicorn.jpg&quot; &lt;img width=&quot;300&quot; src=&quot;https://{URL}&quot;/&gt;   Any Wolfram expressions are allowed inside the braces  URL = {&quot;upload.wikimedia.org/wikipedia/commons/7/70/Oftheunicorn.jpg&quot;} &lt;img width=&quot;300&quot; src=&quot;https://{URL[[1]]}&quot;/&gt;   tip To reduce a load on a garbage collector, please, use With With[{URL = &quot;upload.wikimedia.org/wikipedia/commons/7/70/Oftheunicorn.jpg&quot;}, &lt;img width=&quot;300&quot; src=&quot;https://{URL}&quot;/&gt; ] This prevents WL Kernel from creating temporal symbols  ","version":null,"tagName":"h2"},{"title":"How does it relate to a normal WL symbol?‚Äã","type":1,"pageTitle":"Basics of syntax","url":"/wlx-docs/docs/WLX/basics#how-does-it-relate-to-a-normal-wl-symbol","content":" What you have in those funky XML tags in the end is a normal WL definition. For example  \tAFunction[Any_] := &lt;p&gt;&lt;Any/&gt;&lt;/p&gt;; AFunction[329]   Once .wlx is parsed, it becomes a global definition. However the latter (whether it is global or defined like in Module with a lexical scoping) you can still control, see [[WLX/scoping]].  ","version":null,"tagName":"h2"},{"title":"Iterators, branching?‚Äã","type":1,"pageTitle":"Basics of syntax","url":"/wlx-docs/docs/WLX/basics#iterators-branching","content":" HTML/XML¬†is a markup language by its nature. Therefore it is recommended not to use explicitly¬†Table¬†or¬†If¬†expressions inside XML tags, but rather utilize Wolfram Language for that  Columns[YourList__]¬†:=¬†Table[ &lt;div¬†class=&quot;lg:pr-4&quot;&gt; &lt;div¬†class=&quot;text-base leading-7 text-gray-700¬†&quot;&gt; &lt;Child/&gt; &lt;/div&gt; &lt;/div&gt; , {Child,¬†List[YourList]}]; &lt;div¬†class=&quot;col&quot;&gt; &lt;Columns&gt; &lt;p&gt;This is column 1&lt;/p&gt; &lt;p&gt;This is column 2&lt;/p&gt; &lt;p&gt;This is column 3&lt;/p&gt; &lt;/Columns&gt; &lt;/div&gt;   Here a multiple &lt;p&gt; tags are substituted as a list of arguments to Columns function, that iterates over them and forms a wrapper HTML structure. Then the result is substituted into the bottom div col structure.  Or other there is another way to build lists from raw data  With[{ TableList = Table[ With[{SomeField = item[&quot;Field&quot;]}, &lt;li class=&quot;red&quot;&gt;&lt;SomeField/&gt;&lt;/li&gt; ] , {item, YouList}] }, &lt;ul&gt; &lt;TableList/&gt; &lt;/ul&gt; ]   caution Putting a plain text separated by multiple line breaks &lt;Element&gt; Line 1 Line 2 &lt;/Element&gt; counts as a single argument to the expression Element. However &lt;Element&gt; Line 1 &lt;p&gt;Line 2&lt;/p&gt; &lt;/Element&gt; is already two arguments passed with a string type (atom).  ","version":null,"tagName":"h2"},{"title":"XML attributes === Options‚Äã","type":1,"pageTitle":"Basics of syntax","url":"/wlx-docs/docs/WLX/basics#xml-attributes--options","content":" Traditional Wolfram Language Options can be passed as if it was an HTML attribute  &lt;Heading title={&quot;Some title&quot;}/&gt;   where  Heading[OptionsPattern[]] := With[{Title = OptionValue[&quot;title&quot;]}, &lt;h1&gt;This is some &lt;Title/&gt;&lt;/h1&gt; ] Options[Heading] = {&quot;title&quot; -&gt; &quot;Empty title&quot;}   The only difference is you have to use curly braces unlike in traditional XML attributes for WL symbols.  This can be done for tags with child elements  &lt;TagName option1={Wolfram Expression} option2={...}&gt; whatever &lt;/TagName&gt;   where all passed arguments go firstly and before the OptionsPattern, i.e.  TagName[args__, OptionsPattern[]] := ...  ","version":null,"tagName":"h2"},{"title":"Components","type":0,"sectionRef":"#","url":"/wlx-docs/docs/WLX/components","content":"","keywords":"","version":null},{"title":"Passing named XML attributes‚Äã","type":1,"pageTitle":"Components","url":"/wlx-docs/docs/WLX/components#passing-named-xml-attributes","content":" Let us start from the example. We have a component, that makes italic labels  label.wlx Text = $Options[&quot;Text&quot;]; &lt;i&gt; &lt;TextString&gt; &lt;Text/&gt; &lt;/TextString&gt; &lt;/i&gt;   Then, one can import it in some other .wlx file  Label := ImportComponent[&quot;label.wlx&quot;] &lt;body&gt; &lt;Label Text={&quot;Hello World&quot;}/&gt; &lt;/body&gt;   tip The difference between Set and SetDelayed is the same as in Wolfram Language. If imported component has to generate something with passed arguments - use SetDelayed, if it generates the result immediately or other function - use Set.  It looks similar to what we had in Basics / Options.  This is done in a way, that feels like a regular XML attribute. Or one can pass any valid Wolfram Expression as well  Label := ImportComponent[&quot;label.wlx&quot;] &lt;body&gt; &lt;Label Text={Now}/&gt; &lt;/body&gt;   tip Do not be afraid to import many nested components, since the result of ImportComponent is parsed once into a regular Wolfram Expression and stored in cache. See Caching  ","version":null,"tagName":"h2"},{"title":"Passing children as down-values‚Äã","type":1,"pageTitle":"Components","url":"/wlx-docs/docs/WLX/components#passing-children-as-down-values","content":" To construct a component that uses a normal tags with possibly nested structure - use SetDelayed on ImportComponent. See an example  label.wlx &lt;i&gt; &lt;TextString&gt; &lt;$Children/&gt; &lt;/TextString&gt; &lt;/i&gt;   Then modify the main script as  Label := ImportComponent[&quot;label.wlx&quot;] &lt;body&gt; &lt;Label&gt; &lt;Now/&gt; &lt;/Label&gt; &lt;/body&gt;   Now Label works like a regular symbol with down-values, i.e. one can also do that  Label[Now]   There are a few predefined keywords to have an access to the child elements  ","version":null,"tagName":"h2"},{"title":"$FirstChild‚Äã","type":1,"pageTitle":"Components","url":"/wlx-docs/docs/WLX/components#firstchild","content":" Gets the first passed argument  ","version":null,"tagName":"h3"},{"title":"$Children‚Äã","type":1,"pageTitle":"Components","url":"/wlx-docs/docs/WLX/components#children","content":" Gets all passed arguments (-child elements) as a list  ","version":null,"tagName":"h3"},{"title":"$Options‚Äã","type":1,"pageTitle":"Components","url":"/wlx-docs/docs/WLX/components#options","content":" Get all options passed to a component  ","version":null,"tagName":"h3"},{"title":"Component with internal state‚Äã","type":1,"pageTitle":"Components","url":"/wlx-docs/docs/WLX/components#component-with-internal-state","content":" Quite often one might find useful to keep the whole logic within a single component. Needless to say to store an internal state this construction comes handy  Component.wlx (*/* !!! Will be executed once and stored */*) State = False; Component[OptionsPattern[]] := With[{Mutator = OptionsValue[&quot;Mutator&quot;]}, (*/* !!! Will be executed each time you call */*) State = Mutator[State]; (*/* so something with a given parameters and etc... */*) &lt;h1&gt; &lt;State/&gt; &lt;/h1&gt; ] Options[Component] = {&quot;Mutator&quot; -&gt; Identity} Component (*/* exported */*)   Here the last line returns our generated function. In the main file we can import it once using basic Set expression, i.e.  MyComponent = ImportComponent[&quot;Component.wlx&quot;]; mutate[state_] := !state; ... requestHandler[__] := With[{}, &lt;body&gt; &lt;MyComponent Mutator={mutate}/&gt; &lt;/body&gt; ]; ...   It comes handy, when you need to generate multiple responses for incoming requests and share the internal state of a single component between.  ","version":null,"tagName":"h2"},{"title":"Export multiple entities‚Äã","type":1,"pageTitle":"Components","url":"/wlx-docs/docs/WLX/components#export-multiple-entities","content":" It is also absolute valid to return more than a single symbol like if it was a notebook's cell  Component.wlx State = ... Component[OptionsPattern[]] := ... Script = ... Whatever = ... ... {Component, Script, Whatever} (*/* exported */*)   {MyComponent, MyScript, MyWhatever} = ImportComponent[&quot;Component.wlx&quot;];   *technically speaking we still got a single symbol in return, which is called List ;) *  tip Use it if you have controllers, views or Javascript code which has to be imported as a separate symbols  ","version":null,"tagName":"h3"},{"title":"Context manipulation‚Äã","type":1,"pageTitle":"Components","url":"/wlx-docs/docs/WLX/components#context-manipulation","content":" When designing a package or paclet or just for local context isolation, all Wolfram Language built-in tools are valid to use here as well  Main.wl Begin[&quot;MyContext`&quot;] Component = ImportComponent[&quot;Compoment.wlx&quot;] End[] MyContext`Component   All rules are applied and variables generated in Component will be in the given context.  ","version":null,"tagName":"h3"},{"title":"Scoping‚Äã","type":1,"pageTitle":"Components","url":"/wlx-docs/docs/WLX/components#scoping","content":" By the default it parses a script with Localize option (see scoping), but one the importing function accepts this option pattern as well, so you can override it  Label := ImportComponent[&quot;label.wlx&quot;, &quot;Localize&quot;-&gt;False]   warning This is not recommended, since it will leak into the global scope  ","version":null,"tagName":"h2"},{"title":"Caching‚Äã","type":1,"pageTitle":"Components","url":"/wlx-docs/docs/WLX/components#caching","content":" For the development / prototyping the caching is disabled. To improve the performance and lower the load for IO operations on a disk for many nested component - use global settings  JerryI`WLX`Importer`CacheControl[True]   or specify the time-interval  JerryI`WLX`Importer`Private`CacheControl[&quot;Minute&quot;] JerryI`WLX`Importer`Private`CacheControl[&quot;Hour&quot;]   ","version":null,"tagName":"h2"},{"title":"Path resolution‚Äã","type":1,"pageTitle":"Components","url":"/wlx-docs/docs/WLX/components#path-resolution","content":" ","version":null,"tagName":"h2"},{"title":"UNIX / WIN / WEB‚Äã","type":1,"pageTitle":"Components","url":"/wlx-docs/docs/WLX/components#unix--win--web","content":" To overcome an issue with different path representation implementations, a universal platform-dependent converter is used. Therefore ImportComponent is indifferent for the way how you write the path to a file.  ","version":null,"tagName":"h3"},{"title":"Nested folders‚Äã","type":1,"pageTitle":"Components","url":"/wlx-docs/docs/WLX/components#nested-folders","content":" When you import a component inside other component, an automatic guess happens if the given file is located in the same folder or an absolute path is used, i.e.  Root Main.wlxLabel Label.wlxComponents Someother.wlx  and  Main.wlx ... ... = ImportComponent[&quot;Label/Label.wlx&quot;]   Label/Label.wlx ... ... = ImportComponent[&quot;Components/Someother.wlx&quot;]   are valid. ","version":null,"tagName":"h3"},{"title":"Scoping","type":0,"sectionRef":"#","url":"/wlx-docs/docs/WLX/scoping","content":"","keywords":"","version":null},{"title":"Garbage collection‚Äã","type":1,"pageTitle":"Scoping","url":"/wlx-docs/docs/WLX/scoping#garbage-collection","content":" Unfortunately there is no clear way of purging the symbols created by Module, therefore they are collected into a symbol  JerryI`WLX`Private`garbageCollection   It is up to the user when and how clear them.  warning There is no built-in method to purge unused symbols automatically, since symbols might be needed for the current connection or session, which 100% depends on your application.  The best option would be to have a certain even, that ends the &quot;session&quot; on which your code is subscribed. Then once it happens, on can purge all created symbols at once using pure function  Function[Null, ClearAll[Word]; ]  ","version":null,"tagName":"h2"},{"title":"WebUI","type":0,"sectionRef":"#","url":"/wlx-docs/docs/Reference/WLX/WebUI","content":"","keywords":"","version":null},{"title":"WebUIInitializationScript‚Äã","type":1,"pageTitle":"WebUI","url":"/wlx-docs/docs/Reference/WLX/WebUI#webuiinitializationscript","content":" A helper script, that provides all necessary Javascript code for framework support  WebUIInitializationScript _String   It must be embedded into the head section of your main page template.  ","version":null,"tagName":"h2"},{"title":"WebUIFetch‚Äã","type":1,"pageTitle":"WebUI","url":"/wlx-docs/docs/Reference/WLX/WebUI#webuifetch","content":" Makes an asynchronous request for Wolfram Expression evaluation to a web-page via WebSockets  WebUIFetch[expr_, client_:$Client, opts___] _Promise   the following options are accepted  &quot;Format&quot; -&gt; _ &quot;JSON&quot; a regular JS representation of any object will be imported as List of rules in WL&quot;RawJSON&quot; the same as above, but as nested association&quot;ExpressionJSON&quot; imports JS objects as Wolfram Expressions&quot;Raw&quot; imports result as a string  ","version":null,"tagName":"h2"},{"title":"WebUIEventListener‚Äã","type":1,"pageTitle":"WebUI","url":"/wlx-docs/docs/Reference/WLX/WebUI#webuieventlistener","content":" Attach an event listener on a page to DOM element and directs events to a given EventObject (represented as a string)  WebUIEventListener[opts__] _String   The following options must be provided  &quot;Id&quot; -&gt; _String an id of DOM element&quot;Type&quot; -&gt; &quot;click&quot; type of DOM event (usually click, input, change, blur, focus ...)&quot;Event&quot; -&gt; _String a identifier of EventObject on a server&quot;Pattern&quot; -&gt; &quot;Default&quot; a pattern for event handling&quot;Property&quot; -&gt; &quot;value&quot; what property value will be send to an event object  ","version":null,"tagName":"h2"},{"title":"Example‚Äã","type":1,"pageTitle":"WebUI","url":"/wlx-docs/docs/Reference/WLX/WebUI#example","content":" On any page of your application  EventHandler[&quot;button&quot;, Print]; &lt;div&gt; &lt;button¬†id=&quot;btn&quot; type=&quot;button&quot;&gt;Click Me!&lt;/button&gt; &lt;WebUIEventListener Id={&quot;btn&quot;} Event={&quot;button&quot;} /&gt; &lt;/div&gt;   ","version":null,"tagName":"h3"},{"title":"WebUIKeyListener‚Äã","type":1,"pageTitle":"WebUI","url":"/wlx-docs/docs/Reference/WLX/WebUI#webuikeylistener","content":" Listens keys pressed (user's keyboard) on a page and sends them to a server  WebUIKeyListener[opts__] _String   The following options should be provided  &quot;Event&quot; -&gt; _String a bidirectional events channel (see later)&quot;Pattern&quot; -&gt; &quot;Pressed&quot; a pattern name used for pressed keys codes  ","version":null,"tagName":"h2"},{"title":"Start / stop listening‚Äã","type":1,"pageTitle":"WebUI","url":"/wlx-docs/docs/Reference/WLX/WebUI#start--stop-listening","content":" Use an event-channel provided with Event option to  EventFire[_String, &quot;Start&quot;, &lt;|&quot;Client&quot; -&gt; _|&gt;]   to start listening or  EventFire[_String, &quot;Stop&quot;, &lt;|&quot;Client&quot; -&gt; _|&gt;]   to stop it.  ","version":null,"tagName":"h3"},{"title":"Pressed keys‚Äã","type":1,"pageTitle":"WebUI","url":"/wlx-docs/docs/Reference/WLX/WebUI#pressed-keys","content":" Using the same events channel we can listen all key-codes  EventHandler[_String, {&quot;Pressed&quot; -&gt; Print}];   note There is no need in cloning event object, since patterns does not intersect.  ","version":null,"tagName":"h3"},{"title":"WebUIOnLoad‚Äã","type":1,"pageTitle":"WebUI","url":"/wlx-docs/docs/Reference/WLX/WebUI#webuionload","content":" A component, that fires an event when page was loaded and executed till the place, where it is placed in DOM tree  tip use it to capture connected $Client and subscribe for necessary events such as closing the connection and others...  WebUIOnLoad[opts__] _String   The following options should be provided  &quot;Event&quot; a string representation of EventObject which will be fired once page loaded&quot;Pattern&quot; -&gt; &quot;Default&quot; a pattern for event  ","version":null,"tagName":"h2"},{"title":"Example‚Äã","type":1,"pageTitle":"WebUI","url":"/wlx-docs/docs/Reference/WLX/WebUI#example-1","content":" Once page is loaded a message in the console should appear  EventHandler[&quot;ev&quot;, Function[Null, Print[&quot;Loaded!&quot;]]]; ... &lt;WebUIOnLoad Event={&quot;ev&quot;}/&gt;   ","version":null,"tagName":"h3"},{"title":"WebUIJSBind‚Äã","type":1,"pageTitle":"WebUI","url":"/wlx-docs/docs/Reference/WLX/WebUI#webuijsbind","content":" Attach Javascript code on a page as an EventHandler to a given event-object represented as string  WebUIJSBind[Script__String, opts___] _String   where Script is sequence or a single string with Javascript code. The following options are accepted  &quot;ScriptTag&quot; -&gt; True tells if Javascript code needs to be wrapped using &lt;script&gt; HTML tag&quot;Event&quot; -&gt; _String an identifier event-object on a server  Script can be separated into two sections  &lt;WebUIJSBind Event={&quot;ev&quot;}&gt; //will be executed once const doc = document.body; //binding to event patterns this.on('Pattern 1', async (data) =&gt; { const assoc = await interpretate(data, {hold:true}); const payload = await interpretate(assoc.Payload, {}); alert(payload); }); &lt;/WebUIJSBind&gt;   Then once fired a &quot;Client&quot; socket must be provided as a key of association expression, i.e.  EventFire[&quot;ev&quot;, &quot;Pattern 1&quot;, &lt;|&quot;Client&quot;-&gt;$Client, &quot;Payload&quot; -&gt; &quot;Hello World!&quot;|&gt;]   Payload field is only for illustrative purpose, in principle an entire association arrives to WLJS Interpreter  ","version":null,"tagName":"h2"},{"title":"WebUILazyLoad‚Äã","type":1,"pageTitle":"WebUI","url":"/wlx-docs/docs/Reference/WLX/WebUI#webuilazyload","content":" A container that holds an arbitrary expression, and loads / updates it on a page with provided arguments dynamically when a corresponding event has been fired  WebUILazyLoad[content_, opts__] _String   The following options should be provided  &quot;Event&quot; -&gt; _String an identifier of object on a server  This component leaves an empty div container in the DOM tree, where it is placed  &lt;WebUILazyLoad Event={&quot;event&quot;}&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;/WebUILazyLoad&gt;   A component has HoldFirst attribute.  ","version":null,"tagName":"h2"},{"title":"Accepted commands‚Äã","type":1,"pageTitle":"WebUI","url":"/wlx-docs/docs/Reference/WLX/WebUI#accepted-commands","content":" Each command should be send as a pattern in EventFire with an association in data field  &quot;Load&quot;‚Äã  Evaluates and loads (or updates) content to a page (where this component is places)  EventFire[event_String, &quot;Load&quot;, a_Association]   where a must contain &quot;Client&quot; key with a destination socket object, the rest is up to a user. There is a way on providing data from event to a content expression using WebUILazyLoadDataProvided symbol  &lt;WebUILazyLoad Event={&quot;ev&quot;}&gt; &lt;SomeOtherComponent Data={WebUILazyLoadDataProvided}/&gt; &lt;/WebUILazyLoad&gt;   and  a = &lt;|&quot;Client&quot; -&gt; $Client, &quot;Field1&quot; -&gt; ..., &quot;Field2&quot; -&gt; ..., ...|&gt;   &quot;Remove&quot;‚Äã  Deletes content from the page  &quot;Hide&quot;‚Äã  Appends hidden class to a component  &quot;Show&quot;‚Äã  Removes hidden class from a component  ","version":null,"tagName":"h3"},{"title":"WebUIContainer‚Äã","type":1,"pageTitle":"WebUI","url":"/wlx-docs/docs/Reference/WLX/WebUI#webuicontainer","content":" A variety of WebUIOnLoad component for forming lists with multiple items  WebUIContainer[content_, opts__] _String   where content should have a special structure like a template with a key-symbol WebUIContainerChild, where all children will be inserted  &lt;WebUIContainer Event={&quot;controller&quot;}&gt; &lt;ul&gt; &lt;WebUIContainerChild/&gt; &lt;/ul&gt; &lt;/WebUIContainer&gt;   ","version":null,"tagName":"h2"},{"title":"Append command‚Äã","type":1,"pageTitle":"WebUI","url":"/wlx-docs/docs/Reference/WLX/WebUI#append-command","content":" There is only a single command pattern used  EventFire[&quot;controller&quot;, &quot;Append&quot;, &lt;|&quot;Client&quot;-&gt;$Client, &quot;Data&quot;-&gt;any_String|&gt;]   where &quot;Data&quot; contains new child to be placed where WebUIContainerChild is located in DOM tree.  ","version":null,"tagName":"h3"},{"title":"WebUIRefresh‚Äã","type":1,"pageTitle":"WebUI","url":"/wlx-docs/docs/Reference/WLX/WebUI#webuirefresh","content":" A refreshable container  WebUIRefresh[content__, opts__] _String   A component has HoldAll attribute.  It immediately renders content field into DOM (server-side render), but later refresh it's parent DOM element using new data provided via event. For example  &lt;WebUIRefresh Event={&quot;event&quot;}&gt; &lt;TextString&gt; &lt;Now/&gt; &lt;/TextString&gt; &lt;/WebUIRefresh&gt;   ","version":null,"tagName":"h2"},{"title":"Accepted commands‚Äã","type":1,"pageTitle":"WebUI","url":"/wlx-docs/docs/Reference/WLX/WebUI#accepted-commands-1","content":" All commands are written as patterns in EventFire  &quot;Refresh&quot;‚Äã  Forces a container to reevaluate the content and update its DOM  EventFire[&quot;event&quot;, &quot;Refresh&quot;, &lt;|&quot;Client&quot;-&gt;$Client|&gt;]   &quot;Clear&quot;‚Äã  Removes inner content of a container from a page  &quot;Hide&quot;‚Äã  Adds hidden class  &quot;Show&quot;‚Äã  Removes hidden class  ","version":null,"tagName":"h3"},{"title":"WebUISubmit‚Äã","type":1,"pageTitle":"WebUI","url":"/wlx-docs/docs/Reference/WLX/WebUI#webuisubmit","content":" Submits an expression to be evaluated on WLJS Interpreter (browser's side) aka WLJSTransportSend  WebUISubmit[expr_, client_:$Client] _$Failure | Null   ","version":null,"tagName":"h2"},{"title":"WebUIClose‚Äã","type":1,"pageTitle":"WebUI","url":"/wlx-docs/docs/Reference/WLX/WebUI#webuiclose","content":" Closes window by given socket  WebUIClose[socket_:$Client]   ","version":null,"tagName":"h2"},{"title":"WebUILocation‚Äã","type":1,"pageTitle":"WebUI","url":"/wlx-docs/docs/Reference/WLX/WebUI#webuilocation","content":" Changes a url or opens a new window  WebUILocation[url_String, client_:$Client, opts___]   The following options are supported  &quot;Target&quot; specifies where to open a url. To open in a new window use _ or Blank[] value. ","version":null,"tagName":"h2"},{"title":"Bouncing balls","type":0,"sectionRef":"#","url":"/wlx-docs/docs/WLX/examples/app","content":"","keywords":"","version":null},{"title":"Action‚Äã","type":1,"pageTitle":"Bouncing balls","url":"/wlx-docs/docs/WLX/examples/app#action","content":" To get the most of your attention I (@JerryI - maintainer) would like to start with a short demo of this application    a time jitter is due to the recordings issues  To run this demo  wolframscript -f Examples/Balls/Balls.wls   ","version":null,"tagName":"h2"},{"title":"Description‚Äã","type":1,"pageTitle":"Bouncing balls","url":"/wlx-docs/docs/WLX/examples/app#description","content":" The first example uses HTTP and WS servers and dynamic mode of WLJS Interpreter. The project structure is following  Balls/ public directory Components/ Head.wlx header component Logo.wlx logo of WLX in svg Toggle.wlx a custom toggle button component UI.wlx UI layout of an app App.wlx actual application file with code and logic Main.wlx entry point of any request to an app Balls.wls main startup file   This example widely uses event handling and dynamic symbols we talked about in dynamics section.  Let us have a look at the Main.wlx, which is an entry-point of our requests from client  Main.wlx (* /* importing dynamic components */ *) Head := ImportComponent[&quot;Components/Head.wlx&quot;]; Logo := ImportComponent[&quot;Components/Logo.wlx&quot;]; App = ImportComponent[&quot;App.wlx&quot;]; (* /* HTML Page */ *) ExtensionsJS = (StringJoin[&quot;/&quot;, FileNameToURLPath[#]]) &amp;/@ WLJS`PM`Includes[&quot;js&quot;]; ExtensionsStyles = With[{Path = FileNameToURLPath[#]}, &lt;link rel=&quot;stylesheet&quot; href=&quot;/{Path}&quot;/&gt; ] &amp;/@ WLJS`PM`Includes[&quot;styles&quot;] // ToStringRiffle; Main[request_] := With[{ session = CreateUUID[], controls = CreateUUID[] }, EventHandler[session, {&quot;Connected&quot; -&gt; Function[Null, Echo[&quot;Connected!&quot;]; With[{socket = $Client}, EventHandler[socket, {&quot;Closed&quot; -&gt; Function[Null, Echo[&quot;Closed!!!&quot;]; EventFire[controls, &quot;Destroy&quot;, True]; ]}]; ] ]}]; &lt;html&gt; &lt;Head&gt; &lt;WLJSHeader List={ExtensionsJS}/&gt; &lt;ExtensionsStyles/&gt; &lt;WLJSTransportScript Port={ENV[&quot;WSPort&quot;]} Event={session}/&gt; &lt;/Head&gt; &lt;body&gt; &lt;div class=&quot;min-h-full&quot;&gt; &lt;header class=&quot;bg-white shadow&quot;&gt; &lt;div class=&quot;flex items-center mx-auto max-w-7xl px-4 py-6 sm:px-6 lg:px-8&quot;&gt; &lt;Logo Width={&quot;5em&quot;}/&gt; &lt;h1 class=&quot;text-3xl px-5 font-bold tracking-tight text-gray-900&quot;&gt;App&lt;/h1&gt; &lt;/div&gt; &lt;/header&gt; &lt;main&gt; &lt;div class=&quot;mx-auto max-w-7xl py-6 sm:px-6 lg:px-8&quot;&gt; &lt;App Controls={controls}/&gt; &lt;/div&gt; &lt;/main&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; ] Main   Here it subscribes for &quot;Closed&quot; event from connected socket and causes a global &quot;Destroy&quot; event for App.wlx. Therefore we can cancel created tasks, remove listeners once connection is lost.  In the main application file, things get more interesting  App.wlx (* /* ------------------------------------------------------------ */ *) (* /* Functions, which are global for all instances of a component */ *) append[xy_, pos_, vel_] := With[{}, If[Length[arr] &gt; 100, pos = Append[Drop[pos, 50], xy]; vel = Append[Drop[vel, 50], RandomReal[]/5.0]; , pos = Append[pos, xy]; vel = Append[vel, RandomReal[]/5.0]; ]; ]; SetAttributes[append, HoldRest]; (* /* kinda many bodies sim in real time */ *) manyBodySim[pos_, vels_, damphing_] := Module[{newState = pos}, pos = MapIndexed[With[{i = #2[[1]], y = #1[[2]]}, vels[[i]] = (1.0 - damphing / 10.0) vels[[i]] - Sign[y] 0.1; With[{calculated = y + vels[[i]] 0.1}, (* /* bounce back if hit the ground */ *) If[Sign[y] (calculated) &lt; 0, vels[[i]] = - vels[[i]]; {#1[[1]], Sign[y] 0.001} , {#1[[1]], calculated} ] ] ]&amp;, newState]; ]; SetAttributes[manyBodySim, HoldAll] (* /* Create an instance of widget */ *) create[globalControls_, localControls_] := Module[{ dots = {{0.,0.5}}, vels = {0.}, damping = 0., task = Null, listener }, (*/* mouse position listener */*) listener = {White, EventHandler[Rectangle[{-10, -10}, {10,10}], {&quot;mousemove&quot;-&gt;Function[xy, append[xy, dots, vels]]}]}; (*/* handling events from UI buttons */*) EventHandler[localControls, { &quot;Gravity&quot; -&gt; Function[switch, If[switch, Echo[&quot;Task started&quot;]; task = SetInterval[manyBodySim[dots, vels, damping], 1000/30.]; , Echo[&quot;Task ended&quot;]; TaskRemove[task]; ] ], &quot;Damping&quot; -&gt; Function[value, damping = value] }]; (*/* handling global events */*) EventHandler[globalControls, {&quot;Destroy&quot; -&gt; Function[Null, Echo[&quot;Widget removed!&quot;]; Echo[&quot;Task ended&quot;]; TaskRemove[task]; ]}]; (*/* a an output for WLJS Interpreter */*) Graphics[{ listener, RGBColor[0.1764, 0.8313, 0.74901], PointSize[0.05], Point[Offload[dots]] }, Controls-&gt;True, TransitionDuration-&gt;50, PlotRange-&gt;{{-1,1}, {-1,1}}] ]; (* /* UI components for controls of simulation */ *) UI := ImportComponent[&quot;Components/UI.wlx&quot;]; (* /* ------------------------------------------------------------ */ *) (* /* For each request an App function is called */ *) App[OptionsPattern[]] := With[{ globalControls = OptionValue[&quot;Controls&quot;], localControls = CreateUUID[] }, With[{ PlottingDevice = create[globalControls, localControls] }, &lt;div class=&quot;divide-y divide-gray-200 max-w-lg overflow-hidden rounded-lg bg-white shadow&quot;&gt; &lt;div class=&quot;px-4 py-5 sm:p-6&quot;&gt; &lt;WLJS&gt; &lt;PlottingDevice/&gt; &lt;/WLJS&gt; &lt;/div&gt; &lt;div class=&quot;px-4 py-4 sm:px-6&quot;&gt; &lt;UI Event={localControls}/&gt; &lt;/div&gt; &lt;/div&gt; ] ] App   The interesting thing here is a mouse listener, that works purely on WLJS Interpreter  app.wlx listener = {White, EventHandler[Rectangle[{-10, -10}, {10,10}], {&quot;mousemove&quot;-&gt;Function[xy, append[xy, dots, vels]]}]};   This is a giant rectangle, on which an EventHandler was attached, then each time you move your mouse it fires append function on a server.  Once this toggle switch is pressed  Components/UI.wlx Event = $Options[&quot;Event&quot;]; (* /* custom built UI component */ *) ToggleView := ImportComponent[&quot;Toggle.wlx&quot;]; gravity = CreateUUID[]; EventHandler[gravity, Function[switch, EventFire[Event, &quot;Gravity&quot;, switch]; ]]; (* /* a regular component from wljs-inputs lib. */ *) SliderControl = InputRange[0, 1, 0.1, 0, &quot;Label&quot;-&gt;&quot;Damping&quot;]; EventHandler[SliderControl, Function[value, EventFire[Event, &quot;Damping&quot;, value]; ]]; &lt;ul role=&quot;list&quot; class=&quot;divide-x divide-gray-100&quot;&gt; &lt;li class=&quot;flex justify-between gap-x-6 py-1&quot;&gt; &lt;div class=&quot;flex min-w-0 gap-x-4&quot;&gt; &lt;div class=&quot;min-w-0 flex-auto&quot;&gt; &lt;ToggleView Event={gravity} Label={&quot;Gravity&quot;}/&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class=&quot;flex justify-between gap-x-6 py-1&quot;&gt; &lt;div class=&quot;flex min-w-0 gap-x-4&quot;&gt; &lt;div class=&quot;min-w-0 flex-auto&quot;&gt; &lt;p class=&quot;text-sm font-semibold leading-6 text-gray-900&quot;&gt; &lt;WLJS&gt; &lt;SliderControl/&gt; &lt;/WLJS&gt; &lt;/p&gt; &lt;p class=&quot;mt-1 truncate text-xs leading-5 text-gray-500&quot;&gt;Drag this slider while gravity is on&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt;   It fires this event handler  App.wlx EventHandler[localControls, { &quot;Gravity&quot; -&gt; Function[switch, If[switch, Echo[&quot;Task started&quot;]; task = SetInterval[manyBodySim[dots, vels, damping], 1000/30.]; , Echo[&quot;Task ended&quot;]; TaskRemove[task]; ] ], &quot;Damping&quot; -&gt; Function[value, damping = value] }];   which starts a task (scoped for each instance of an App), that performs calculations of dot's coordinates and velocities in a gravity field. ","version":null,"tagName":"h2"},{"title":"Guidelines","type":0,"sectionRef":"#","url":"/wlx-docs/docs/WLX/WebUI Library/intro","content":"","keywords":"","version":null},{"title":"Store state only on server‚Äã","type":1,"pageTitle":"Guidelines","url":"/wlx-docs/docs/WLX/WebUI Library/intro#store-state-only-on-server","content":" It is very hesitating to use pure JS in order to keep the slider's state or switches in the browser, even some logic of your application. However, it leads to some complicated problems to be solved such as data or state synchronization, management of shared states and etc for which senior React developers got paid. If everything you create does not escape the borders of your [[component]] and Wolfram Language it will make your life easier.  The presented framework was designed mostly for a desktop or cloud-based applications with 1-3 users (browsers tabs don't count) and a single instance of Wolfram Kernel running. Storing everything on a server comes with almost zero cost of resources.  tip Even if you have a single button, use WebUIEventListener and handle its action on a server.  ","version":null,"tagName":"h3"},{"title":"Use Javascript for DOM manipulations only‚Äã","type":1,"pageTitle":"Guidelines","url":"/wlx-docs/docs/WLX/WebUI Library/intro#use-javascript-for-dom-manipulations-only","content":" or for decorative purposes  Every action has to be approved by the server's logic. Thinking about it if you were writing a regular desktop application (using QT for example). WebSockets is no longer a bottleneck for a simple UI actions, such as typing or clicking a button.  ","version":null,"tagName":"h3"},{"title":"Enforce server side-rendering‚Äã","type":1,"pageTitle":"Guidelines","url":"/wlx-docs/docs/WLX/WebUI Library/intro#enforce-server-side-rendering","content":" This is done automatically, since there is no client-side rendering (or hydrator like in React or Angular) tool provided. The general idea is to send a ready-to-go HTML tree including supporting Javascript code via WebSockets, similar to setInnerHTML method used on a web. See WebUILazyLoad, WebUIContainer, WebUIRefresh and etc.  ","version":null,"tagName":"h3"},{"title":"Preparations‚Äã","type":1,"pageTitle":"Guidelines","url":"/wlx-docs/docs/WLX/WebUI Library/intro#preparations","content":" The following libraries are needed for proper functioning of WebUI framework  WLXImporterWLJSEventsPromiseWLJSTransportAsync  WebUI is a dynamic framework, which demands a live WebSocket connection. Here is a server script with comments, that provides a minimal set of libraries for a working server  Server.wls #!/usr/bin/env wolframscript (* ::Package:: *) SetDirectory[If[StringQ[NotebookDirectory[] ], NotebookDirectory[], DirectoryName[$InputFileName] ] ] Uncompress[&quot;1:eJx1T8tuwjAQDBT1wo0/6Ac0vveKKAoNCJoDZ5NugsXGtrwbBf6edawKLlzG+5rxzMfJ/TZvWZbRVKBomkms5wLfBmF1NcR0qN6lL/fbfMC0j4Q18 PM80mkmcDR8TlexK0Ug7SKnAh5f9F0aRoGi8y5wVUp5Zvb0pVTQQ96KTn/qCULtLIPlvHad2kAIt0IN+Imu1uh1fdEtkOq0seoHggVUydForuJgbJsCLgSWTj7r7d/q6gMQGWfT Lt7KLPp4ZPq3+qz0Iv6Yddcj3gGoDVPG&quot;]; PacletRepositories[{ Github -&gt; &quot;https://github.com/KirillBelovTest/Objects&quot;, Github -&gt; &quot;https://github.com/KirillBelovTest/Internal&quot;, Github -&gt; &quot;https://github.com/JerryI/CSocketListener&quot; -&gt; &quot;dev2024&quot;, Github -&gt; &quot;https://github.com/KirillBelovTest/TCPServer&quot;, Github -&gt; &quot;https://github.com/KirillBelovTest/HTTPHandler&quot;, Github -&gt; &quot;https://github.com/KirillBelovTest/WebSocketHandler&quot;, Github -&gt; &quot;https://github.com/JerryI/wl-misc&quot; -&gt; &quot;dev&quot;, Github -&gt; &quot;https://github.com/JerryI/wl-wljs-packages&quot;, Github -&gt; &quot;https://github.com/JerryI/wl-wlx&quot; }] RandomWord[]; (* Here you can configure *) ENV = &lt;| &quot;WSPort&quot; -&gt; 8011, &quot;HTTPPort&quot; -&gt; 8010, &quot;Host&quot; -&gt; &quot;127.0.0.1&quot; |&gt; ENV[&quot;HAddr&quot;] := StringTemplate[&quot;``:``&quot;][ENV[&quot;Host&quot;], ENV[&quot;HTTPPort&quot;]] ENV[&quot;WAddr&quot;] := StringTemplate[&quot;``:``&quot;][ENV[&quot;Host&quot;], ENV[&quot;WSPort&quot;]] (* TCP Server *) &lt;&lt;KirillBelov`Objects` &lt;&lt;KirillBelov`Internal` &lt;&lt;KirillBelov`CSockets` &lt;&lt;KirillBelov`TCPServer` (* HTTP services *) &lt;&lt;KirillBelov`HTTPHandler` &lt;&lt;KirillBelov`HTTPHandler`Extensions` (* WS services *) &lt;&lt;KirillBelov`WebSocketHandler` (* WLX services *) &lt;&lt;JerryI`WLX` &lt;&lt;JerryI`WLX`Importer` &lt;&lt;JerryI`WLX`WLJS` &lt;&lt;JerryI`WLX`WebUI` (* Events system and WLJS communication *) &lt;&lt;JerryI`Misc`Events` &lt;&lt;KirillBelov`CSockets`EventsExtension` &lt;&lt;JerryI`Misc`WLJS`Transport` &lt;&lt;JerryI`Misc`Async` &lt;&lt;JerryI`WLJSPM` WLJS`PM`Repositories[{ Github -&gt; &quot;https://github.com/JerryI/wljs-interpreter&quot; -&gt; &quot;dev&quot; }] (* import libs data *) Map[Function[path, Block[{System`$RemotePackageDirectory = FileNameJoin[{&quot;wljs_packages&quot;, FileNameSplit[path] // First}]}, FileNameJoin[{&quot;wljs_packages&quot;, path}] // Get // Quiet; ]; ], WLJS`PM`Includes[&quot;kernel&quot;] ]; Print[&quot;Staring HTTP server...&quot;]; tcp = TCPServer[]; tcp[&quot;CompleteHandler&quot;, &quot;HTTP&quot;] = HTTPPacketQ -&gt; HTTPPacketLength; tcp[&quot;MessageHandler&quot;, &quot;HTTP&quot;] = HTTPPacketQ -&gt; http; (* Entry Point for all requests *) App = ImportComponent[&quot;App.wlx&quot;]; http = HTTPHandler[]; http[&quot;MessageHandler&quot;, &quot;Index&quot;] = AssocMatchQ[&lt;|&quot;Method&quot; -&gt; &quot;GET&quot;|&gt;] -&gt; App SocketListen[CSocketOpen[ENV[&quot;HAddr&quot;]], tcp@#&amp;] Print[&quot;Staring WS/HTTP server...&quot;]; wcp = TCPServer[] wcp[&quot;CompleteHandler&quot;, &quot;WebSocket&quot;] = WebSocketPacketQ -&gt; WebSocketPacketLength wcp[&quot;MessageHandler&quot;, &quot;WebSocket&quot;] = WebSocketPacketQ -&gt; ws (* configure the handler for WLJS communications *) ws = WebSocketHandler[] ws[&quot;MessageHandler&quot;, &quot;Evaluate&quot;] = Function[True] -&gt; WLJSTransportHandler SocketListen[CSocketOpen[ENV[&quot;WAddr&quot;]], wcp@#&amp;, &quot;SocketEventsHandler&quot;-&gt;CSocketsClosingHandler] StringTemplate[&quot;open http://``&quot;][ENV[&quot;HAddr&quot;]] // Print; While[True, Pause[1]];   warning This section is still in development. Please see Reference WebUIA couple of examples are available: TodoList and some in the repository folder. ","version":null,"tagName":"h2"},{"title":"Installation","type":0,"sectionRef":"#","url":"/wlx-docs/docs/WLX/install","content":"","keywords":"","version":null},{"title":"Development server‚Äã","type":1,"pageTitle":"Installation","url":"/wlx-docs/docs/WLX/install#development-server","content":" tip It is optional and is up to your application, however, running an HTTP server locally to see the changes in WLX script you made will be much more convenient, than exporting static HTML pages to a file.  We would recommend a high-performance server built by @KirillBelovTest running on a custom written TCP sockets library.  A shortcut If you have git installed. Simply clone git clone https://github.com/JerryI/wl-wlx cd wl-wlx wolframscript -f Examples/Basic/Basic.wls that will run the simplest example possible  Here is a boilerplate code, that just works out from the box  (* package manager to make sure you will get the right version *) Uncompress[&quot;1:eJx1T8tuwjAQDBT1wo0/6Ac0vveKKAoNCJoDZ5NugsXGtrwbBf6edawKLlzG+5rxzMfJ/TZvWZbRVKBomkms5wLfBmF1NcR0qN6lL/fbfMC0j4Q18 PM80mkmcDR8TlexK0Ug7SKnAh5f9F0aRoGi8y5wVUp5Zvb0pVTQQ96KTn/qCULtLIPlvHad2kAIt0IN+Imu1uh1fdEtkOq0seoHggVUydForuJgbJsCLgSWTj7r7d/q6gMQGWfT Lt7KLPp4ZPq3+qz0Iv6Yddcj3gGoDVPG&quot;]; (* setting the directory of the project *) SetDirectory[If[StringQ[NotebookDirectory[]], NotebookDirectory[], DirectoryName[$InputFileName]]] PacletRepositories[{ Github -&gt; &quot;https://github.com/KirillBelovTest/Objects&quot;, Github -&gt; &quot;https://github.com/KirillBelovTest/Internal&quot;, Github -&gt; &quot;https://github.com/JerryI/CSocketListener&quot; -&gt; &quot;dev2024&quot;, Github -&gt; &quot;https://github.com/KirillBelovTest/TCPServer&quot;, Github -&gt; &quot;https://github.com/KirillBelovTest/HTTPHandler&quot;, Github -&gt; &quot;https://github.com/JerryI/wl-wlx&quot; }] &lt;&lt;KirillBelov`CSockets` &lt;&lt;KirillBelov`Objects` &lt;&lt;KirillBelov`Internal` &lt;&lt;KirillBelov`TCPServer` &lt;&lt;KirillBelov`HTTPHandler` &lt;&lt;KirillBelov`HTTPHandler`Extensions` (* WLX scripts *) &lt;&lt;JerryI`WLX` &lt;&lt;JerryI`WLX`Importer` Print[&quot;Staring HTTP server...&quot;]; tcp = TCPServer[]; tcp[&quot;CompleteHandler&quot;, &quot;HTTP&quot;] = HTTPPacketQ -&gt; HTTPPacketLength; tcp[&quot;MessageHandler&quot;, &quot;HTTP&quot;] = HTTPPacketQ -&gt; http; index := ImportComponent[&quot;Index.wlx&quot;]; http = HTTPHandler[]; http[&quot;MessageHandler&quot;, &quot;Index&quot;] = AssocMatchQ[&lt;|&quot;Method&quot; -&gt; &quot;GET&quot;|&gt;] -&gt; Function[x, index[x]] SocketListen[CSocketOpen[&quot;127.0.0.1:8010&quot;], tcp@# &amp;]; &quot;open http://127.0.0.1:8010/&quot;//Print; While[True, Pause[0.1]];   info Please, save your notebook or .wls script to some directory  This code will run an http server at 127.0.0.1:8010 and serve a single file Index.wlx. Therefore you should open the root folder of your script or notebook and create the following file  yourproject/Index.wlx Main := ImportComponent[&quot;Main.wlx&quot;]; &lt;Main Request={$FirstChild}/&gt;   This will redirect the request to Main.wlx, where you application will be located. It forces Wolfram Kernel to dynamically import it every-time you open a web-page, unlike Index.wlx, which was imported once and cached at the startup.  yourproject/main.wlx (* /* HTML Page */ *) &lt;html&gt; &lt;head&gt; &lt;title&gt;WLX Template&lt;/title&gt; &lt;link href=&quot;https://unpkg.com/tailwindcss@^1.0/dist/tailwind.min.css&quot; rel=&quot;stylesheet&quot;/&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;min-h-full&quot;&gt; &lt;header class=&quot;bg-white shadow&quot;&gt; &lt;div class=&quot;flex items-center mx-auto max-w-7xl px-4 py-6 sm:px-6 lg:px-8&quot;&gt; &lt;h1 class=&quot;text-3xl font-bold tracking-tight text-gray-900&quot;&gt;Title&lt;/h1&gt; &lt;/div&gt; &lt;/header&gt; &lt;main&gt; &lt;div class=&quot;mx-auto max-w-7xl py-6 sm:px-6 lg:px-8&quot;&gt; Local time &lt;TextString&gt;&lt;Now/&gt;&lt;/TextString&gt; &lt;/div&gt; &lt;/main&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;   info Every-time you change something at Main.wlx, the result will be shown once you refresh the page in your browser.  Here for the more appealing look, a well-known Tailwind CSS framework is used. The expected result is shown below   ","version":null,"tagName":"h2"},{"title":"Running WL in a browser","type":0,"sectionRef":"#","url":"/wlx-docs/docs/WLX/interpeter","content":"","keywords":"","version":null},{"title":"Preparations‚Äã","type":1,"pageTitle":"Running WL in a browser","url":"/wlx-docs/docs/WLX/interpeter#preparations","content":" warning The packages used in this tutorial cannot be downloaded using native Wolfram Paclet manager. Please consider to use LPM Get[&quot;https://raw.githubusercontent.com/JerryI/wl-localpackages/main/Kernel/LPM.wl&quot;] (* or just download this will and add it to your project *)   In order to scope all libraries to your project and provide paths to necessary CSS tables and Javascript files we need to add a couple of libraries  (* LPM Autoinstall and cache *) Uncompress[&quot;1:eJx1T8tuwjAQDBT1wo0/6Ac0vveKKAoNCJoDZ5NugsXGtrwbBf6edawKLlzG+5rxzMfJ/TZvWZbRVKBomkms5wLfBmF1NcR0qN6lL/fbfMC0j4Q18 PM80mkmcDR8TlexK0Ug7SKnAh5f9F0aRoGi8y5wVUp5Zvb0pVTQQ96KTn/qCULtLIPlvHad2kAIt0IN+Imu1uh1fdEtkOq0seoHggVUydForuJgbJsCLgSWTj7r7d/q6gMQGWfT Lt7KLPp4ZPq3+qz0Iv6Yddcj3gGoDVPG&quot;]; PacletRepositories[{ Github -&gt; &quot;https://github.com/KirillBelovTest/Objects&quot;, Github -&gt; &quot;https://github.com/KirillBelovTest/Internal&quot;, Github -&gt; &quot;https://github.com/JerryI/CSocketListener&quot; -&gt; &quot;dev2024&quot;, Github -&gt; &quot;https://github.com/KirillBelovTest/TCPServer&quot;, Github -&gt; &quot;https://github.com/KirillBelovTest/HTTPHandler&quot;, Github -&gt; &quot;https://github.com/JerryI/wl-wlx&quot;, Github -&gt; &quot;https://github.com/JerryI/wl-wljs-packages&quot; }]   The last line added is a package manager used by WLJS Notebook (yet another package manager), but comes handy here as well.  Then a few more modifications (code continues)   &lt;&lt;KirillBelov`Objects` &lt;&lt;KirillBelov`Internal` &lt;&lt;KirillBelov`CSockets` &lt;&lt;KirillBelov`TCPServer` &lt;&lt;KirillBelov`HTTPHandler` &lt;&lt;KirillBelov`HTTPHandler`Extensions` &lt;&lt;JerryI`WLJSPM` WLJS`PM`Repositories[{ Github -&gt; &quot;https://github.com/JerryI/wljs-interpreter&quot; -&gt; &quot;dev&quot;, Github -&gt; &quot;https://github.com/JerryI/wljs-graphics-d3&quot; -&gt; &quot;dev&quot; }] &lt;&lt;JerryI`WLX` &lt;&lt;JerryI`WLX`Imported` &lt;&lt;JerryI`WLX`WLJS`   The first two links highlighted are  wljs-interpreter an interpreter of WL running on Javascript enginewljs-graphics-d3 2D graphics library  There are more libraries available...  wljs-plotly Alternative 2D plots using Plotly.jswljs-inputs a GUI elements like buttons, slides and etc (see in section dynamics)wljs-graphics3d-threejs 3D graphics  note Those libraries are borrowed from WLJS Notebooks  The last few things concerns about HTTP server settings (code continues)  Print[&quot;Staring HTTP server...&quot;]; tcp = TCPServer[]; tcp[&quot;CompleteHandler&quot;, &quot;HTTP&quot;] = HTTPPacketQ -&gt; HTTPPacketLength; tcp[&quot;MessageHandler&quot;, &quot;HTTP&quot;] = HTTPPacketQ -&gt; http; index := ImportComponent[&quot;Components/Index.wlx&quot;]; http = HTTPHandler[]; http[&quot;MessageHandler&quot;, &quot;File&quot;] = GetFileRequestQ[{&quot;css&quot;, &quot;js&quot;}] -&gt; ( ImportFile[#, &quot;Base&quot; -&gt; {&quot;wljs_packages&quot;}] &amp; ) http[&quot;MessageHandler&quot;, &quot;Index&quot;] = AssocMatchQ[&lt;|&quot;Method&quot; -&gt; &quot;GET&quot;|&gt;] -&gt; Function[x, index[x]] (* ::End::*) SocketListen[CSocketOpen[&quot;127.0.0.1:8010&quot;], tcp@# &amp;]; (* import wljs-libs data *) Map[Function[path, Block[{System`$RemotePackageDirectory = FileNameJoin[{&quot;wljs_packages&quot;, FileNameSplit[path] // First}]}, FileNameJoin[{&quot;wljs_packages&quot;, path}] // Get // Quiet; ]; ], WLJS`PM`Includes[&quot;kernel&quot;] ]; &quot;open http://127.0.0.1:8010&quot; // Print; While[True, Pause[1];];   The highlighted lines are for resolving URLs pointing to above-mentioned libraries and imports inner Wolfram Language packages.  ","version":null,"tagName":"h2"},{"title":"Page design‚Äã","type":1,"pageTitle":"Running WL in a browser","url":"/wlx-docs/docs/WLX/interpeter#page-design","content":" Now a boilerplate code as we have seen in the previous sections  Components/Index.wlx Main := ImportComponent[&quot;Main.wlx&quot;]; &lt;Main Request={$FirstChild}/&gt;   note In principle you don't have to use this intermediate Index.wlx file and import directly Main.wlx. However here it forces WLX importer to perform parsing for every request, so that one can observe changes without restarting Wolfram Kernel.  Now our entry-point component  Components/Main.wlx (* /* HTML Page */ *) ExtensionsJS = (FileNameToURLPath[#]) &amp;/@ WLJS`PM`Includes[&quot;js&quot;]; ExtensionsStyles = With[{Path = FileNameToURLPath[#]}, &lt;link rel=&quot;stylesheet&quot; href=&quot;{Path}&quot;/&gt; ] &amp;/@ WLJS`PM`Includes[&quot;styles&quot;] // ToStringRiffle; App = ImportComponent[&quot;App.wlx&quot;]; &lt;html&gt; &lt;head&gt; &lt;title&gt;WLX Template&lt;/title&gt; &lt;link href=&quot;https://unpkg.com/tailwindcss@^1.0/dist/tailwind.min.css&quot; rel=&quot;stylesheet&quot;/&gt; &lt;WLJSHeader List={ExtensionsJS}/&gt; &lt;ExtensionsStyles/&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;min-h-full&quot;&gt; &lt;header class=&quot;bg-white shadow&quot;&gt; &lt;div class=&quot;flex items-center mx-auto max-w-7xl px-4 py-6 sm:px-6 lg:px-8&quot;&gt; &lt;h1 class=&quot;text-3xl font-bold tracking-tight text-gray-900&quot;&gt;WLJS Basics&lt;/h1&gt; &lt;/div&gt; &lt;/header&gt; &lt;main&gt; &lt;App/&gt; &lt;/main&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html   Those lines are for embedding necessary Javascript and CSS tables to the head element of our page, which will be imported by server from our wljs libraries.  Now everything is set, we can move on to the main part.  ","version":null,"tagName":"h2"},{"title":"Usage‚Äã","type":1,"pageTitle":"Running WL in a browser","url":"/wlx-docs/docs/WLX/interpeter#usage","content":" An access to the interpreter can be done by wrapping Wolfram Expressions via special tag or function  Components/App.wlx P = Plot[Sin[x], {x, -2Pi, 2Pi}]; &lt;div class=&quot;mx-auto max-w-7xl py-6 sm:px-6 lg:px-8&quot;&gt; &lt;WLJS&gt;&lt;P/&gt;&lt;/WLJS&gt; &lt;/div&gt;   or  Components/App.wlx P = Plot[Sin[x], {x, -2Pi, 2Pi}] // WLJS; &lt;div class=&quot;mx-auto max-w-7xl py-6 sm:px-6 lg:px-8&quot;&gt; &lt;P/&gt; &lt;/div&gt;     What it does it exports the result of the evaluation to ExpressionJSON and embeds it to the page, where the tag is located. Lately when the page is loaded, a javascript code will be executed. If there is any graphics output presented it will embed it directly to the &lt;div&gt; element.  note Most 2D plotting functions of Mathematica are covered, as well as 3D, but with some limitations. Please consider the reference section on those libraries.  ","version":null,"tagName":"h2"},{"title":"Styling‚Äã","type":1,"pageTitle":"Running WL in a browser","url":"/wlx-docs/docs/WLX/interpeter#styling","content":" One can pass any class names (from CSS table) to &lt;WLJS&gt; tag to customize the output  &lt;style&gt; .myClass { position:absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto; } &lt;/style&gt; &lt;WLJS Class={&quot;myClass&quot;}&gt;&lt;P/&gt;&lt;/WLJS&gt;   ","version":null,"tagName":"h2"},{"title":"Inputs, buttons, UI...?‚Äã","type":1,"pageTitle":"Running WL in a browser","url":"/wlx-docs/docs/WLX/interpeter#inputs-buttons-ui","content":" To use GUI element as etc., please have a look @ dynamics section.  ","version":null,"tagName":"h2"},{"title":"A note on Javascript functions‚Äã","type":1,"pageTitle":"Running WL in a browser","url":"/wlx-docs/docs/WLX/interpeter#a-note-on-javascript-functions","content":" This is covered by WLJS Interpreter, however the general idea is, that any symbol with own- or down- values is represented as  &lt;script type=&quot;module&quot;&gt; core.MyFunction = async (args, env) =&gt; { const data = await interpretate(args[0], env); element.innerHTML = data; } &lt;/script&gt;   try to embed the following symbol onto a page  Test = MyFunction[&quot;Hello World!&quot;]; &lt;WLJS&gt;&lt;Test/&gt;&lt;/WLJS   or if you use XML attributes  &lt;script type=&quot;module&quot;&gt; core.MyFunction = async (args, env) =&gt; { const data = await core._getRules(args, env); console.log(data); } &lt;/script&gt;   and  &lt;WLJS&gt;&lt;MyFunction Data={&quot;Hello World&quot;}/&gt;&lt;/WLJS   check the browser's console.  There are much more to cover on this topic. Please consider to read the original docs on WLJS Interpreter. ","version":null,"tagName":"h2"},{"title":"Todo list","type":0,"sectionRef":"#","url":"/wlx-docs/docs/WLX/examples/todolist","content":"","keywords":"","version":null},{"title":"Approach 1‚Äã","type":1,"pageTitle":"Todo list","url":"/wlx-docs/docs/WLX/examples/todolist#approach-1","content":" To run this demo  git clone https://github.com/JerryI/wl-wlx cd wl-wlx wolframscript -f Examples/WebUITodo/Server.wls   All notes are stored a basic association with two fields inside Checked and Content. This is how an instance of App looks like  App[OptionsPattern[]] := With[{ controls = CreateUUID[], listController = CreateUUID[] }, Module[{ typed = &quot;&quot; }, EventHandler[controls, { &quot;Loaded&quot; -&gt; Function[Null, attachListeners[$Client, controls] ], &quot;New&quot; -&gt; Function[Null, With[{uid = CreateUUID[]}, NotesDatabase[uid] = &lt;|&quot;Content&quot; -&gt; typed, &quot;Checked&quot; -&gt; False|&gt;; typed = &quot;&quot;; EventFire[AppState, RecordChange[], Null]; ]; ], &quot;Type&quot; -&gt; Function[data, Echo[data]; typed = data; ] }]; &lt;div class=&quot;flex items-center justify-center font-medium&quot;&gt; &lt;div class=&quot;flex flex-grow items-center justify-center h-full text-gray-600 bg-gray-100&quot;&gt; &lt;div class=&quot;max-w-full p-8 bg-white rounded-lg shadow-lg w-96&quot;&gt; &lt;Header/&gt; &lt;WebUIRefresh Event={controls}&gt; &lt;NotesList Database={NotesDatabase} OnUpdate={updateNote}/&gt; &lt;/WebUIRefresh&gt; &lt;AddButton Event={controls}/&gt; &lt;/div&gt; &lt;WebUIOnLoad Event={controls} Pattern={&quot;Loaded&quot;}/&gt; &lt;/div&gt; &lt;/div&gt; ] ] App   For each request, an app instance is generated. Of course control buttons are scoped within the instance. First thing that happens - a static view of NoteList is rendered on a server inside a refreshable component WebUIRefresh.  Then once a connection is established using WebUIOnLoad an instance subscribes for local events  &quot;New&quot; when a + button was clicked&quot;Type&quot; stands for typing listeners, that reads text user typed in a field for a new note and stores in locally to be used once &quot;New&quot; is fired  A refreshing of notes list is done externally using controls symbol, which points outside the App instance to a global event. Once user clicks on checkbox in NotesList component it redirects its actions to updateNote function  updateNote[uid_String, state_String, client_] := With[{}, NotesDatabase[uid, &quot;Checked&quot;] = (state === &quot;true&quot;); EventFire[AppState, RecordChange[], client]; ]   which preform changes in the database and fires global event to force all connected clients to refresh a NotesList component.  ","version":null,"tagName":"h2"},{"title":"Approach 2‚Äã","type":1,"pageTitle":"Todo list","url":"/wlx-docs/docs/WLX/examples/todolist#approach-2","content":" To run this demo  git clone https://github.com/JerryI/wl-wlx cd wl-wlx wolframscript -f Examples/WebUITodoV2/Server.wls   The major difference will be, that now we tried to threat notes as individual objects with individual view components. The benefits of it, that we do not have to worry about on how we shown and update their states, once something changes. We render an component, that comes with its listeners, controls and make an individual binding to a client.  Now we need mutable objects (achieved using Objects library written by Kirill Belov)  init[n_] := With[{uid = CreateUUID[]}, n[&quot;Hash&quot;] = uid; n]; CreateType[Note, init, {&quot;Content&quot;-&gt;&quot;&quot;, &quot;Checked&quot;-&gt;False}]; Note /: EventHandler[n_Note, rest__] := EventHandler[n[&quot;Hash&quot;], rest]; Note /: EventFire[n_Note, rest__] := EventFire[n[&quot;Hash&quot;], rest]; Note /: EventClone[n_Note] := EventClone[n[&quot;Hash&quot;]];   Here we also extend Events system to make possible to subscribe for any changes on a given Note object.  Each note is a live widget, then we need write a component for it including all logic and controllers as well as method for destroying  Item.wlx Note = $Options[&quot;Note&quot;]; UId = Note[&quot;Hash&quot;]; removeButton = CreateUUID[]; Controls = $Options[&quot;Controls&quot;]; Client = $Options[&quot;Client&quot;]; Controller = CreateUUID[]; clonedEvent = EventClone[Note]; detector = EventClone[Client]; EventHandler[detector, {&quot;Closed&quot; -&gt; Function[Null, destoryWidget]}]; destoryWidget := With[{}, Echo[&quot;Item &gt;&gt; Item.wlx &gt;&gt; destroyed!&quot;]; EventRemove[detector]; EventRemove[clonedEvent]; EventRemove[Controller]; ]; (* /* States changes */ *) EventHandler[clonedEvent, { &quot;Checked&quot; -&gt; Function[data, With[{client = Client}, If[data[&quot;Client&quot;] === client, Return[]]; EventFire[Controller, &quot;SetState&quot;, Join[data, &lt;|&quot;Client&quot; -&gt; client|&gt; ]]; ] ], &quot;Destroy&quot; -&gt; Function[data, EventFire[Controller, &quot;Remove&quot;, &lt;|&quot;Client&quot; -&gt; Client|&gt;]; ] }]; (* /* Listening actions from widget */ *) EventHandler[EventClone @ Controller, { &quot;Checked&quot; -&gt; Function[state, With[{n = Note}, n[&quot;Checked&quot;] = state === &quot;true&quot;; ]; EventFire[Note, &quot;Checked&quot;, &lt;|&quot;Client&quot; -&gt; Client, &quot;Data&quot; -&gt; (state === &quot;true&quot;)|&gt;]; ], &quot;Destroy&quot; -&gt; Function[Null, Echo[&quot;Remove!&quot;]; EventFire[Note, &quot;Destroy&quot;, &lt;|&quot;Client&quot; -&gt; Client|&gt;]; ] }]; (* /* a hack for HTML to display correctly checked state */ *) InputChecked = If[Note[&quot;Checked&quot;], &lt;input class=&quot;hidden&quot; type=&quot;checkbox&quot; id=&quot;{UId}&quot; checked=&quot;true&quot;/&gt; , &lt;input class=&quot;hidden&quot; type=&quot;checkbox&quot; id=&quot;{UId}&quot;/&gt; ]; Content = Note[&quot;Content&quot;]; &lt;div&gt; &lt;InputChecked/&gt; &lt;label class=&quot;flex items-center h-10 px-2 rounded cursor-pointer hover:bg-gray-100&quot; for=&quot;{UId}&quot;&gt; &lt;span class=&quot;flex items-center justify-center w-5 h-5 text-transparent border-2 border-gray-300 rounded-full&quot;&gt; &lt;svg class=&quot;w-4 h-4 fill-current&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 20 20&quot; fill=&quot;currentColor&quot;&gt; &lt;path fill-rule=&quot;evenodd&quot; d=&quot;M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z&quot; clip-rule=&quot;evenodd&quot; /&gt; &lt;/svg&gt; &lt;/span&gt; &lt;span class=&quot;ml-4 text-sm&quot;&gt;&lt;Content/&gt;&lt;/span&gt; &lt;svg id=&quot;{removeButton}&quot; class=&quot;ml-auto rotate-45 w-5 h-5 text-gray-400 fill-current&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt; &lt;path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; stroke-width=&quot;2&quot; d=&quot;M12 6v6m0 0v6m0-6h6m-6 0H6&quot; /&gt; &lt;/svg&gt; &lt;/label&gt; &lt;WebUIEventListener Event={Controller} Pattern={&quot;Destroy&quot;} Id={removeButton}/&gt; &lt;WebUIEventListener Event={Controller} Type={&quot;change&quot;} Property={&quot;checked&quot;} Pattern={&quot;Checked&quot;} Id={UId}/&gt; &lt;WebUIJSBind Event={Controller}&gt; const el = document.getElementById('&lt;UId/&gt;'); this.on('SetState', async (data) =&gt; { const assoc = await interpretate(data, {hold:true}); const state = await interpretate(assoc.Data, {}); console.log(state); el.checked = state; }) this.on('Remove', () =&gt; { console.warn('Destroy!'); el.parentNode.remove(); }) &lt;/WebUIJSBind&gt; &lt;/div&gt;   As one can see this widget  represents an Note[], but can also mutate itlistens its UI elements (Controller) and broadcast changes to subscriber of Note[] objectupdates view of Note[] based on clonedEvent, which is a copy of event-object assigned to a given Note[]  Here is is quite common to clone events, in order not to interfere with other widgets, which are associated with the same note.  To display a list of notes, one could use WebUILazyLoad and WebUIContainer with Append feature to dynamically add a new note without redrawing all previous (saves a lot of resources)   &lt;WebUIContainer Event={controller}&gt; &lt;div class=&quot;mt-0 shrink-0 gap-y-1 flex flex-col&quot;&gt; &lt;WebUILazyLoad Event={LazyLoad}&gt; &lt;NotesList/&gt; &lt;/WebUILazyLoad&gt; &lt;WebUIContainerChild/&gt; &lt;WebUIOnLoad Event={controls} Pattern={&quot;Load&quot;}/&gt; &lt;/div&gt; &lt;/WebUIContainer&gt;   Here WebUILazyLoad is only used to display notes, which were already in a database on the moment when a user opened a new page  NotesList := With[{client = $Client}, Table[Item[&quot;Note&quot;-&gt;note, &quot;Client&quot;-&gt;client, &quot;Controls&quot;-&gt;controls], {note, ReleaseHold[Database]} ] // Flatten // ToStringRiffle ]   while WebUIContainerChild is going to host all new notes added when a page has been loaded already like it is done in this line  EventHandler[clonedAppEvents, { &quot;Append&quot; -&gt; Function[note, EventFire[controller, &quot;Append&quot;, &lt;|&quot;Client&quot;-&gt;client, &quot;Data&quot; -&gt; Item[&quot;Note&quot;-&gt;note, &quot;Client&quot;-&gt;client, &quot;Controls&quot;-&gt;controls] |&gt; ]; ] }];   In principle, one could get rid of WebUILazyLoad and render previous notes on a server, but then an Client object must be provided. So a widget would need to subscribe for a new connection using WebUIOnLoad for example, instead of having this object already when loaded using WebUILazyLoad and then add all listeners   &lt;WebUIContainer Event={controller}&gt; &lt;div class=&quot;mt-0 shrink-0 gap-y-1 flex flex-col&quot;&gt; &lt;NotesListModified/&gt; &lt;WebUIContainerChild/&gt; &lt;WebUIOnLoad Event={controls} Pattern={&quot;Load&quot;}/&gt; &lt;/div&gt; &lt;/WebUIContainer&gt;   But this would need to add some extra lines to a widget component to consider this case ","version":null,"tagName":"h2"},{"title":"Dynamics and interactivity","type":0,"sectionRef":"#","url":"/wlx-docs/docs/WLX/dynamics","content":"","keywords":"","version":null},{"title":"Preparations‚Äã","type":1,"pageTitle":"Dynamics and interactivity","url":"/wlx-docs/docs/WLX/dynamics#preparations","content":" We are going to use WebSockets protocol for the real-time communication. for that one need to set up a corresponding server WebSocketHandler written by Kirill Belov. Please see his repo for more details regarding this server. One need only to set an hostname and port for it and assign it to a separate TCP server.  Let us rewrite our wolfram script file  Uncompress[&quot;1:eJx1T8tuwjAQDBT1wo0/6Ac0vveKKAoNCJoDZ5NugsXGtrwbBf6edawKLlzG+5rxzMfJ/TZvWZbRVKBomkms5wLfBmF1NcR0qN6lL/fbfMC0j4Q18 PM80mkmcDR8TlexK0Ug7SKnAh5f9F0aRoGi8y5wVUp5Zvb0pVTQQ96KTn/qCULtLIPlvHad2kAIt0IN+Imu1uh1fdEtkOq0seoHggVUydForuJgbJsCLgSWTj7r7d/q6gMQGWfT Lt7KLPp4ZPq3+qz0Iv6Yddcj3gGoDVPG&quot;]; PacletRepositories[{ Github -&gt; &quot;https://github.com/KirillBelovTest/Objects&quot;, Github -&gt; &quot;https://github.com/KirillBelovTest/Internal&quot;, Github -&gt; &quot;https://github.com/JerryI/CSocketListener&quot; -&gt; &quot;dev2024&quot;, Github -&gt; &quot;https://github.com/KirillBelovTest/TCPServer&quot;, Github -&gt; &quot;https://github.com/KirillBelovTest/HTTPHandler&quot;, Github -&gt; &quot;https://github.com/KirillBelovTest/WebSocketHandler&quot;, Github -&gt; &quot;https://github.com/JerryI/wl-wljs-packages&quot;, Github -&gt; &quot;https://github.com/JerryI/wl-misc&quot; -&gt; &quot;dev&quot; }] RandomWord[]; (* Here you can configure *) ENV = &lt;| &quot;WSPort&quot;-&gt;8011, &quot;HTTPPort&quot;-&gt;8010, &quot;Host&quot;-&gt;&quot;127.0.0.1&quot; |&gt; ENV[&quot;HAddr&quot;] := StringTemplate[&quot;``:``&quot;][ENV[&quot;Host&quot;], ENV[&quot;HTTPPort&quot;]] ENV[&quot;WAddr&quot;] := StringTemplate[&quot;``:``&quot;][ENV[&quot;Host&quot;], ENV[&quot;WSPort&quot;]] (* TCP Server *) &lt;&lt;KirillBelov`Objects` &lt;&lt;KirillBelov`Internal` &lt;&lt;KirillBelov`CSockets` &lt;&lt;KirillBelov`TCPServer` (* HTTP services *) &lt;&lt;KirillBelov`HTTPHandler` &lt;&lt;KirillBelov`HTTPHandler`Extensions` (* WS services *) &lt;&lt;KirillBelov`WebSocketHandler` (* Event handling and WLJS communication *) &lt;&lt;JerryI`Misc`Events` &lt;&lt;JerryI`Misc`Async` &lt;&lt;JerryI`Misc`WLJS`Transport` &lt;&lt;JerryI`WLX` &lt;&lt;JerryI`WLX`Imported` &lt;&lt;JerryI`WLX`WLJS`   To handle the connection between WLJS Interpreter and Wolfram Kernel another package WLJSTransport is used. All communication with browser is going to be an event-based. Therefore we need Events library, which is not available @ Wolfram Paclet Repository as well as some others library, and can be installed only using LPM package manager, since it modifies system functions.  To have a basic GUI elements we use wljs-inputs (see reference) library  code continues  &lt;&lt;JerryI`WLJSPM` WLJS`PM`Repositories[{ Github -&gt; &quot;https://github.com/JerryI/wljs-interpreter&quot; -&gt; &quot;dev&quot;, Github -&gt; &quot;https://github.com/JerryI/wljs-graphics-d3&quot; -&gt; &quot;dev&quot;, Github -&gt; &quot;https://github.com/JerryI/wljs-inputs&quot; -&gt; &quot;dev&quot; }] (* import libs data *) Map[Function[path, Block[{System`$RemotePackageDirectory = FileNameJoin[{&quot;wljs_packages&quot;, FileNameSplit[path] // First}]}, FileNameJoin[{&quot;wljs_packages&quot;, path}] // Get // Quiet; ]; ], WLJS`PM`Includes[&quot;kernel&quot;] ];   Now a new TCP server has to be started in our to establish a new type of real-time communication channel  code continues  Print[&quot;Staring HTTP server...&quot;]; tcp = TCPServer[]; tcp[&quot;CompleteHandler&quot;, &quot;HTTP&quot;] = HTTPPacketQ -&gt; HTTPPacketLength; tcp[&quot;MessageHandler&quot;, &quot;HTTP&quot;] = HTTPPacketQ -&gt; http; (* our main file for all requests *) App = ImportComponent[&quot;App.wlx&quot;]; http = HTTPHandler[]; http[&quot;MessageHandler&quot;, &quot;File&quot;] = GetFileRequestQ[{&quot;css&quot;, &quot;js&quot;}] -&gt; ( ImportFile[#, &quot;Base&quot; -&gt; {&quot;wljs_packages&quot;}] &amp; ) http[&quot;MessageHandler&quot;, &quot;Index&quot;] = AssocMatchQ[&lt;|&quot;Method&quot; -&gt; &quot;GET&quot;|&gt;] -&gt; App SocketListen[CSocketOpen[ENV[&quot;HAddr&quot;]], tcp@#&amp;] Print[&quot;Staring WS/HTTP server...&quot;]; wcp = TCPServer[] wcp[&quot;CompleteHandler&quot;, &quot;WebSocket&quot;] = WebSocketPacketQ -&gt; WebSocketPacketLength wcp[&quot;MessageHandler&quot;, &quot;WebSocket&quot;] = WebSocketPacketQ -&gt; ws ws = WebSocketHandler[] (* configure the handler for WLJS communications *) ws[&quot;MessageHandler&quot;, &quot;Evaluate&quot;] = Function[True] -&gt; WLJSTransportHandler SocketListen[CSocketOpen[ENV[&quot;WAddr&quot;]], wcp@#&amp;] StringTemplate[&quot;open http://``&quot;][ENV[&quot;HAddr&quot;]] // Print; While[True, Pause[1]];   Now we have finished with minor preparations of server. Let us move on to our App's logic  App.wlx Inputs = ImportComponent[&quot;Components/Inputs.wlx&quot;]; ExtensionsJS = (StringJoin[&quot;&quot;, FileNameToURLPath[#]]) &amp;/@ WLJS`PM`Includes[&quot;js&quot;]; ExtensionsStyles = With[{Path = StringJoin[&quot;&quot;, FileNameToURLPath[#]]}, &lt;link rel=&quot;stylesheet&quot; href=&quot;{Path}&quot;/&gt; ] &amp;/@ WLJS`PM`Includes[&quot;styles&quot;] // ToStringRiffle; (* /* HTML Page */ *) App[request_] := With[{}, &lt;html&gt; &lt;head&gt; &lt;title&gt;WLX Template&lt;/title&gt; &lt;link href=&quot;https://unpkg.com/tailwindcss@^1.0/dist/tailwind.min.css&quot; rel=&quot;stylesheet&quot;/&gt; &lt;WLJSHeader List={ExtensionsJS}/&gt; &lt;ExtensionsStyles/&gt; &lt;WLJSTransportScript Port={ENV[&quot;WSPort&quot;]}/&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;min-h-full&quot;&gt; &lt;header class=&quot;bg-white shadow&quot;&gt; &lt;div class=&quot;flex items-center mx-auto max-w-7xl px-4 py-6 sm:px-6 lg:px-8&quot;&gt; &lt;h1 class=&quot;text-3xl font-bold tracking-tight text-gray-900&quot;&gt;Dynamics&lt;/h1&gt; &lt;/div&gt; &lt;/header&gt; &lt;main&gt; &lt;div class=&quot;flex col mx-auto max-w-7xl py-6 sm:px-6 lg:px-8&quot;&gt; &lt;div class=&quot;mx-4 py-3 px-3 col rounded-lg bg-white shadow&quot;&gt; &lt;Inputs Request={request}/&gt; &lt;/div&gt; &lt;/div&gt; &lt;/main&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; ]; App   The line in the head's section embeds a special header script to establish WebSocket connection. An imported component Components/Inputs.wlx is going to be our sandbox for experiments  ","version":null,"tagName":"h2"},{"title":"Usage‚Äã","type":1,"pageTitle":"Dynamics and interactivity","url":"/wlx-docs/docs/WLX/dynamics#usage","content":" To utilize full power of reactive framework, one need to consider a concept of Events library. The basic idea would be  Components/Inputs.wlx Component[OptionsPattern[]] := Module[{Button}, Button = InputButton[]; EventHandler[Button, Function[Null, Print[&quot;Pressed!&quot;]; ]]; &lt;div class=&quot;flex flex-row gap-x-10&quot;&gt; &lt;WLJS&gt; &lt;Button/&gt; &lt;/WLJS&gt; &lt;/div&gt; ] Component   tip Please consider to have a look at reference section on wljs-inputs library.  By pressing a button, one should see messages in the console    There are a couple more input elements, which can be embedded on a page  InputTextInputRangeInputFileInputCheckbox  More about them one can find here in the reference section. However, you don't have to limit yourself with prebuilt blocks. One can always craft your own UI components using WLX  ","version":null,"tagName":"h2"},{"title":"Crafting UI components‚Äã","type":1,"pageTitle":"Dynamics and interactivity","url":"/wlx-docs/docs/WLX/dynamics#crafting-ui-components","content":" Let us create a new component called Toggle.wlx in the project's Components folder. The easiest way is to pick up one of Tailwind's component and add necessary logic to it  Components/Toggle.wlx Component[OptionsPattern[]] := With[{ Dom = CreateUUID[], Label = OptionValue[&quot;Label&quot;], Event = OptionValue[&quot;Event&quot;], State = OptionValue[&quot;State&quot;], ButtonClass = If[OptionValue[&quot;State&quot;], &quot;bg-wlx-500&quot;, &quot;&quot;], SpanClass = If[OptionValue[&quot;State&quot;], &quot;translate-x-5&quot;, &quot;&quot;] }, &lt;div class=&quot;flex items-center&quot;&gt; &lt;style&gt; .bg-wlx-500 { background-color: #2dd4bf; } &lt;/style&gt; &lt;button id=&quot;{Dom}&quot; type=&quot;button&quot; class=&quot;bg-gray-200 relative inline-flex h-6 w-12 flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-indigo-600 focus:ring-offset-2 {ButtonClass}&quot; role=&quot;switch&quot;&gt; &lt;span state=&quot;{State}&quot; aria-hidden=&quot;true&quot; class=&quot;translate-x-0 pointer-events-none inline-block h-5 w-6 transform rounded-full bg-white shadow ring-0 transition duration-200 ease-in-out {SpanClass}&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;span class=&quot;ml-3 text-sm&quot;&gt; &lt;span class=&quot;mb-1 text-gray-900&quot;&gt;&lt;Label/&gt;&lt;/span&gt; &lt;/span&gt; &lt;script type=&quot;module&quot;&gt; const button = document.getElementById(&quot;&lt;Dom/&gt;&quot;); const span = button.firstChild; let state = span.getAttribute('state') == 'True'; button.addEventListener(&quot;click&quot;, () =&gt; { button.classList.toggle(&quot;bg-wlx-500&quot;); span.classList.toggle(&quot;translate-x-5&quot;); state = ~state; server.kernel.emitt(&quot;&lt;Event/&gt;&quot;, state ? 'True' : 'False') }) &lt;/script&gt; &lt;/div&gt; ] Options[Component] = {&quot;State&quot; -&gt; False, &quot;Label&quot; -&gt; &quot;Toggle&quot;, &quot;Event&quot; -&gt; Null} Component   Here a component comes with its supporting Javascript code, that sends events to a server. Let us have a look closely  button.addEventListener(&quot;click&quot;, () =&gt; { //animation button.classList.toggle(&quot;bg-wlx-500&quot;); span.classList.toggle(&quot;translate-x-5&quot;); //internal state for animation state = ~state; //send a new state to a server server.kernel.emitt(&quot;&lt;Event/&gt;&quot;, state ? 'True' : 'False') })   The last line is the most important, it uses API from WLJSTransport, that exposes server object, which has a method for us  .emitt(event_uid, data)   Then we can capture those events on a server. Let us add it to our previous example  Components/Inputs.wlx Toggle = ImportComponent[&quot;Toggle.wlx&quot;]; sharedState = False; Component[OptionsPattern[]] := Module[{ Button }, With[{ toggle = CreateUUID[] }, EventHandler[toggle, Function[state, sharedState = state; ]]; Button = InputButton[]; EventHandler[Button, Function[Null, Print[&quot;Pressed!&quot;]; ]]; &lt;div class=&quot;flex flex-row gap-x-10&quot;&gt; &lt;WLJS&gt; &lt;Button/&gt; &lt;/WLJS&gt; &lt;Toggle Event={toggle} State={sharedState}/&gt; &lt;/div&gt; ] ] Component   As one can see, now we update sharedState, which is global across all connections. If one reloads a page, the position of a toggle switch will be preserved.  The desired result should look like this    This is a great start, but still haven't tried to change anything on a page!  ","version":null,"tagName":"h3"},{"title":"Call actions on a page‚Äã","type":1,"pageTitle":"Dynamics and interactivity","url":"/wlx-docs/docs/WLX/dynamics#call-actions-on-a-page","content":" To manipulate DOM elements or call an arbitrary Javascript code from the server, we can use the same Wolfram Language expressions. For example lets attach a call to one of our buttons  Components/Inputs.wlx ... Button = InputButton[]; EventHandler[Button, Function[Null, Print[&quot;Pressed!&quot;]; WLJSTransportSend[Alert[&quot;Pressed!&quot;], $Client] ]]; ...   Alert is a built-in function defined in WLJS Interpreter. A window will pop up on a page, once first button is pressed.  ","version":null,"tagName":"h2"},{"title":"DOM Manipulation‚Äã","type":1,"pageTitle":"Dynamics and interactivity","url":"/wlx-docs/docs/WLX/dynamics#dom-manipulation","content":" To manipulate DOM we need to write a WL function for it in Javascript. For example, let it be a text field  &lt;input type=&quot;text&quot; id=&quot;text&quot; class=&quot;block w-full rounded-md border-0 py-1.5 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-gray-400 focus:ring-2 focus:ring-inset focus:ring-indigo-600 sm:text-sm sm:leading-6&quot;/&gt;   then using Javascript, we can access this element on a page and change its content  const element = document.getElementById('text'); core.UpdateText = async (args, env) =&gt; { element.value = await interpretate(args[0], env); }   From server's side we directly call this function as  WLJSTransportSend[UpdateText[RandomWord[]], $Client]   Wrapping it all, we can modify our code as follows  Components/Inputs.wlx Toggle = ImportComponent[&quot;Toggle.wlx&quot;]; sharedState = False; TextDisplay = With[{}, &lt;input type=&quot;text&quot; id=&quot;text&quot; class=&quot;block w-full rounded-md border-0 py-1.5 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-gray-400 focus:ring-2 focus:ring-inset focus:ring-indigo-600 sm:text-sm sm:leading-6&quot;/&gt; &lt;script type=&quot;module&quot;&gt; const element = document.getElementById('text'); core.UpdateText = async (args, env) =&gt; { element.value = await interpretate(args[0], env); } &lt;/script&gt; ] Component[OptionsPattern[]] := Module[{ Button }, With[{ toggle = CreateUUID[] }, EventHandler[toggle, Function[state, sharedState = state; ]]; Button = InputButton[]; EventHandler[Button, Function[Null, Print[&quot;Pressed!&quot;]; WLJSTransportSend[UpdateText[RandomWord[]], $Client]; ]]; &lt;div class=&quot;flex flex-row gap-x-10&quot;&gt; &lt;WLJS&gt; &lt;Button/&gt; &lt;/WLJS&gt; &lt;Toggle Event={toggle} State={sharedState}/&gt; &lt;TextDisplay/&gt; &lt;/div&gt; ] ] Component   The desired result is quite predictable    tip Write building blocks for each section or element of UI and arrange them using solely WLX and Event system. Try to avoid using Javascript outside those components.  tip Try WebUI framework if you prefer write less Javascript code  ","version":null,"tagName":"h3"},{"title":"Dynamic symbols‚Äã","type":1,"pageTitle":"Dynamics and interactivity","url":"/wlx-docs/docs/WLX/dynamics#dynamic-symbols","content":" This is completely independent and different approach to update data on a page, which is based on Wolfram Language symbols and lexical scoping.  The idea arises from a problem of synchronization between WL symbols on browser's and server's sites. By the default an unknown for WLJS Interpreter symbols is requested and later tracked, i.e. all changes of it on a server will be sent to an associated client    Moreover such symbols has special attribute and can be seen from nested expressions by WL interpreter and on each change the connected branch will be reevaluated on your browser. It allows to improve the performance, since only reevaluation of dependent parts happens with no communication to a Wolfram Kernel at all    And lastly, during partial reevaluation involved expressions are executed using different methods, which are highly optimized, i.e.  core.Expression = async (args, env) =&gt; { //initialization and etc ... //do some complicated work } core.Expression.update = async (args, env) =&gt; { ... //do something more simplifed }   info More about an architecture one can read in this guide.  warning Not all defined functions in WLJS Interpreter support such methods. Please see the reference section.  Luckily most case scenarios for graphics are covered, especially Line, Point and other primitives.  ","version":null,"tagName":"h2"},{"title":"Preparations‚Äã","type":1,"pageTitle":"Dynamics and interactivity","url":"/wlx-docs/docs/WLX/dynamics#preparations-1","content":" In order to support this a few tweaks has to be done with WLJSTransport. Please modify your server script as follows  ws = WebSocketHandler[] (* configure the handler for WLJS communications *) ws[&quot;MessageHandler&quot;, &quot;Evaluate&quot;] = Function[True] -&gt; WLJSTransportHandler (* symbols tracking *) WLJSTransportHandler[&quot;AddTracking&quot;] = Function[{symbol, name, cli, callback}, Print[&quot;Add tracking... for &quot;&lt;&gt;name]; Experimental`ValueFunction[Unevaluated[symbol]] = Function[{y,x}, callback[cli, x]]; , HoldFirst] WLJSTransportHandler[&quot;GetSymbol&quot;] = Function[{expr, client, callback}, Print[&quot;Evaluating the desired symbol on the Kernel&quot;]; callback[expr // ReleaseHold]; ]   It stands for resolving requests for such symbols from browser's side and tracking their changes. That's basically all when it comes to setting it up.  Let's add a new component to our example  App.wlx Inputs = ImportComponent[&quot;Components/Inputs.wlx&quot;]; Symbols = ImportComponent[&quot;Components/Symbols.wlx&quot;]; ExtensionsJS = (StringJoin[&quot;&quot;, FileNameToURLPath[#]]) &amp;/@ WLJS`PM`Includes[&quot;js&quot;]; ExtensionsStyles = With[{Path = StringJoin[&quot;&quot;, FileNameToURLPath[#]]}, &lt;link rel=&quot;stylesheet&quot; href=&quot;{Path}&quot;/&gt; ] &amp;/@ WLJS`PM`Includes[&quot;styles&quot;] // ToStringRiffle; (* /* HTML Page */ *) App[request_] := With[{}, &lt;html&gt; &lt;head&gt; &lt;title&gt;WLX Template&lt;/title&gt; &lt;link href=&quot;https://unpkg.com/tailwindcss@^1.0/dist/tailwind.min.css&quot; rel=&quot;stylesheet&quot;/&gt; &lt;WLJSHeader List={ExtensionsJS}/&gt; &lt;ExtensionsStyles/&gt; &lt;WLJSTransportScript Port={ENV[&quot;WSPort&quot;]}/&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;min-h-full&quot;&gt; &lt;header class=&quot;bg-white shadow&quot;&gt; &lt;div class=&quot;flex items-center mx-auto max-w-7xl px-4 py-6 sm:px-6 lg:px-8&quot;&gt; &lt;h1 class=&quot;text-3xl font-bold tracking-tight text-gray-900&quot;&gt;Dynamics&lt;/h1&gt; &lt;/div&gt; &lt;/header&gt; &lt;main&gt; &lt;div class=&quot;flex col mx-auto max-w-7xl py-6 sm:px-6 lg:px-8&quot;&gt; &lt;div class=&quot;mx-4 py-3 px-3 col rounded-lg bg-white shadow&quot;&gt; &lt;Inputs Request={request}/&gt; &lt;/div&gt; &lt;div class=&quot;mx-4 py-3 px-3 col rounded-lg bg-white shadow&quot;&gt; &lt;Symbols Request={request}/&gt; &lt;/div&gt; &lt;/div&gt; &lt;/main&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; ]; App   Now an actual example  ","version":null,"tagName":"h3"},{"title":"Usage‚Äã","type":1,"pageTitle":"Dynamics and interactivity","url":"/wlx-docs/docs/WLX/dynamics#usage-1","content":" The binding between Wolfram Kernel symbols and variables located at your browser is done automatically if it is wrapped using Offload expression  Components/Symbols.wlx Component[OptionsPattern[]] := Module[{ p = {{0,0}}, Canvas, task }, Canvas = Graphics[{ Magenta, Point[Offload[p]] }, PlotRange-&gt;{{-1,1},{-1,1}}, TransitionDuration-&gt;100, TransitionType-&gt;&quot;Linear&quot; ]; task = SetInterval[ p = Append[p, Last[p] + 0.1 RandomReal[{-1,1},2]]; , 100]; &lt;WLJS&gt; &lt;Canvas/&gt; &lt;/WLJS&gt; ] Component   Here a typical Graphics expression is used, however, a symbols with points inside pts is wrapped in Offload, that leaves an inner symbol unevaluated. Then every 100~ms an asynchronous task appends new points to it.  info SetInterval is a shortcut for SchelduledTask from Async package.  The result is following    note This canvas and its points are unique for each connected client or window.  caution You should detect a closed connection in order to remove symbols, tasks or other objects which load the main kernel. Please see the next section.  ","version":null,"tagName":"h3"},{"title":"Binding to the connection state‚Äã","type":1,"pageTitle":"Dynamics and interactivity","url":"/wlx-docs/docs/WLX/dynamics#binding-to-the-connection-state","content":" In the example above every request causes SetInterval to be evaluated, but it is good to have a method to detect if a client closed a window and abort the task or collect garbage.  ","version":null,"tagName":"h2"},{"title":"Preparations‚Äã","type":1,"pageTitle":"Dynamics and interactivity","url":"/wlx-docs/docs/WLX/dynamics#preparations-2","content":" Modify the main script as follows  ... (* Event handling and WLJS communication *) &lt;&lt;JerryI`Misc`Events` &lt;&lt;KirillBelov`CSockets`EventsExtension` &lt;&lt;JerryI`Misc`WLJS`Transport` &lt;&lt;JerryI`Misc`Async` ... SocketListen[CSocketOpen[ENV[&quot;WAddr&quot;]], wcp@#&amp;, &quot;SocketEventsHandler&quot;-&gt;CSocketsClosingHandler]   This will redirect all events regarding the socket state to a special handler function CSocketsClosingHandler, which redirects them to Events system.  Now for each $Client we can attach an EventHandler and check if it is alive or not. For the convenience we can do it globally for the whole App. Let us add a few more line  App.wlx Inputs = ImportComponent[&quot;Components/Inputs.wlx&quot;]; Symbols = ImportComponent[&quot;Components/Symbols.wlx&quot;]; ExtensionsJS = (StringJoin[&quot;&quot;, FileNameToURLPath[#]]) &amp;/@ WLJS`PM`Includes[&quot;js&quot;]; ExtensionsStyles = With[{Path = StringJoin[&quot;&quot;, FileNameToURLPath[#]]}, &lt;link rel=&quot;stylesheet&quot; href=&quot;{Path}&quot;/&gt; ] &amp;/@ WLJS`PM`Includes[&quot;styles&quot;] // ToStringRiffle; (* /* HTML Page */ *) App[request_] := With[{ Session = CreateUUID[], Controls = CreateUUID[] }, EventHandler[Session, {&quot;Connected&quot; -&gt; Function[Null, Echo[&quot;Connected!&quot;]; With[{socket = $Client}, EventHandler[socket, {&quot;Closed&quot; -&gt; Function[Null, EventFire[Controls, &quot;Destroy&quot;, True]; ]}]; ] ]}]; &lt;html&gt; &lt;head&gt; &lt;title&gt;WLX Template&lt;/title&gt; &lt;link href=&quot;https://unpkg.com/tailwindcss@^1.0/dist/tailwind.min.css&quot; rel=&quot;stylesheet&quot;/&gt; &lt;WLJSHeader List={ExtensionsJS}/&gt; &lt;ExtensionsStyles/&gt; &lt;WLJSTransportScript Port={ENV[&quot;WSPort&quot;]} Event={Session}/&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;min-h-full&quot;&gt; &lt;header class=&quot;bg-white shadow&quot;&gt; &lt;div class=&quot;flex items-center mx-auto max-w-7xl px-4 py-6 sm:px-6 lg:px-8&quot;&gt; &lt;h1 class=&quot;text-3xl font-bold tracking-tight text-gray-900&quot;&gt;Dynamics&lt;/h1&gt; &lt;/div&gt; &lt;/header&gt; &lt;main&gt; &lt;div class=&quot;flex col mx-auto max-w-7xl py-6 sm:px-6 lg:px-8&quot;&gt; &lt;div class=&quot;mx-4 py-3 px-3 col rounded-lg bg-white shadow&quot;&gt; &lt;Inputs Controls={Controls} Request={request}/&gt; &lt;/div&gt; &lt;div class=&quot;mx-4 py-3 px-3 col rounded-lg bg-white shadow&quot;&gt; &lt;Symbols Controls={Controls} Request={request}/&gt; &lt;/div&gt; &lt;/div&gt; &lt;/main&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; ]; App   A provided Event option value of WLJSTransportScript fires an event &quot;Connected&quot;, where we can capture an identifier of connected client and subscribe for connection state. Once &quot;Closed&quot; has been captured, we fire a global &quot;Destroy&quot; event on Controls. The last one is distributed over all used components using XML attributes as shown above.  Now it is possible to cancel a running task in section above by subscribing to &quot;Destroy&quot; event  Component/Symbols.wlx Component[OptionsPattern[]] := Module[{ p = {{0.,0.}}, Canvas, task, controls = EventClone @ OptionValue[&quot;Controls&quot;] }, EventHandler[controls, {&quot;Destroy&quot; -&gt; Function[Null, Echo[&quot;Destroyed!&quot;]; TaskRemove[task]; ]}]; Canvas = Graphics[{ Magenta, Point[Offload[p]] }, PlotRange-&gt;{{-1,1},{-1,1}}, TransitionDuration-&gt;100, TransitionType-&gt;&quot;Linear&quot; ]; task = SetInterval[ p = Append[p, Last[p] + 0.1 RandomReal[{-1,1},2]]; , 100]; &lt;WLJS&gt; &lt;Canvas/&gt; &lt;/WLJS&gt; ] Component  ","version":null,"tagName":"h3"}],"options":{"disableVersioning":true,"id":"default"}}