"use strict";(self.webpackChunkwlx_docs=self.webpackChunkwlx_docs||[]).push([[6560],{8168:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>d});var o=s(7624),t=s(2172);const l={},r=void 0,i={id:"Reference/WLX/Importer",title:"Importer",description:"ImportComponent",source:"@site/docs/Reference/WLX/Importer.md",sourceDirName:"Reference/WLX",slug:"/Reference/WLX/Importer",permalink:"/wlx-docs/docs/Reference/WLX/Importer",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedAt:1708366829,formattedLastUpdatedAt:"Feb 19, 2024",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"WLX",permalink:"/wlx-docs/docs/Reference/WLX/"},next:{title:"WLJS",permalink:"/wlx-docs/docs/Reference/WLX/WLJS"}},c={},d=[{value:"<code>ImportComponent</code>",id:"importcomponent",level:2},{value:"<code>path</code>",id:"path",level:3},{value:"Nested folders",id:"nested-folders",level:4},{value:"<code>opts</code>",id:"opts",level:3},{value:"Notes on <code>SetDelayed</code> and <code>Set</code>",id:"notes-on-setdelayed-and-set",level:3},{value:"<code>$Options</code>",id:"options",level:2},{value:"<code>$FirstChild</code>",id:"firstchild",level:2},{value:"<code>$Children</code>",id:"children",level:2},{value:"<code>CacheControl</code>",id:"cachecontrol",level:2}];function a(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.M)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-mathematica",children:"<<JerryI`WLX`Importer`\n"})}),"\n",(0,o.jsx)(n.h2,{id:"importcomponent",children:(0,o.jsx)(n.code,{children:"ImportComponent"})}),"\n",(0,o.jsx)(n.p,{children:"Is used to import WLX files as Wolfram Expressions"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-mathematica",children:"ImportComponent[path_String, opts___] ___\n"})}),"\n",(0,o.jsxs)(n.p,{children:["an imported file is processed using [[Reference/WLX/WLX#",(0,o.jsx)(n.code,{children:"ProcessString"}),"]]  immediately. The result can be cached and then used without costs of parsing."]}),"\n",(0,o.jsx)(n.h3,{id:"path",children:(0,o.jsx)(n.code,{children:"path"})}),"\n",(0,o.jsxs)(n.p,{children:["A universal path resolver is used, it ",(0,o.jsx)(n.strong,{children:"is indifferent for the way how you write the path to a file in Unix- or Windows-style"}),"."]}),"\n",(0,o.jsx)(n.h4,{id:"nested-folders",children:"Nested folders"}),"\n",(0,o.jsx)(n.p,{children:"When you import a component inside other component, an automatic guess happens if the given file is located in the same folder or an absolute path is used, i.e."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Root","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.em,{children:"Main.wlx"})}),"\n",(0,o.jsxs)(n.li,{children:["Label","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.em,{children:"Label.wlx"})}),"\n",(0,o.jsxs)(n.li,{children:["Components","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.em,{children:"Someother.wlx"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"and"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",metastring:'title="Main.wlx"',children:'...\n... = ImportComponent["Label/Label.wlx"]\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",metastring:'title="Label/Label.wlx"',children:'...\n... = ImportComponent["Components/Someother.wlx"]\n'})}),"\n",(0,o.jsx)(n.p,{children:"are valid."}),"\n",(0,o.jsx)(n.h3,{id:"opts",children:(0,o.jsx)(n.code,{children:"opts"})}),"\n",(0,o.jsx)(n.p,{children:"The following options are valid"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:'"Localize" -> _Bool'})," is the same as for ",(0,o.jsx)(n.a,{href:"/wlx-docs/docs/Reference/WLX/#%60ProcessString%60",children:(0,o.jsx)(n.code,{children:"ProcessString"})}),". Default value is ",(0,o.jsx)(n.code,{children:"True"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(n.h3,{id:"notes-on-setdelayed-and-set",children:["Notes on ",(0,o.jsx)(n.code,{children:"SetDelayed"})," and ",(0,o.jsx)(n.code,{children:"Set"})]}),"\n",(0,o.jsxs)(n.p,{children:["Normally once component imported it can be assigned to a symbol. However, ",(0,o.jsx)(n.code,{children:"SetDelayed"})," still imports a component, but keeps an parsed expression unevaluated (",(0,o.jsx)(n.code,{children:"Hold"}),"), i.e."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:'Component := ImportComponent["Component.wlx"];\n\n<Component Option={Whatever}/>\n'})}),"\n",(0,o.jsx)(n.p,{children:"where"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",metastring:'title="Component.wlx"',children:'With[{Opt = $Options["Option"]},\n\t<h1><Opt/></h1>\t\n]\n'})}),"\n",(0,o.jsxs)(n.p,{children:["While the typical case for ",(0,o.jsx)(n.code,{children:"Set"})," operator is when a component returns a function, i.e."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:'Component = ImportComponent["Component.wlx"];\n\n<Component Option={Whatever}/>\n'})}),"\n",(0,o.jsx)(n.p,{children:"and"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",metastring:'title="Component.wlx"',children:'Component[OptionsPattern[]] := With[{Opt = OptionValue["Option"]},\n\t<h1><Opt/></h1>\t\n]\n\nComponent\n'})}),"\n",(0,o.jsx)(n.h2,{id:"options",children:(0,o.jsx)(n.code,{children:"$Options"})}),"\n",(0,o.jsx)(n.p,{children:"Is a global symbol that provides access to all passed XML attributes to a WLX component"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-mathematica",children:"$Options _Association\n"})}),"\n",(0,o.jsx)(n.h2,{id:"firstchild",children:(0,o.jsx)(n.code,{children:"$FirstChild"})}),"\n",(0,o.jsx)(n.p,{children:"A global symbol that provides access to the first passed child (as XML children) or an argument (like in normal WL) to a WLX component"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-mathematica",children:"$FirstChild _\n"})}),"\n",(0,o.jsx)(n.h2,{id:"children",children:(0,o.jsx)(n.code,{children:"$Children"})}),"\n",(0,o.jsx)(n.p,{children:"A global symbol that provides access to all passed children (as XML children) or arguments (like in normal WL) to a WLX component"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-mathematica",children:"$Children _List\n"})}),"\n",(0,o.jsx)(n.h2,{id:"cachecontrol",children:(0,o.jsx)(n.code,{children:"CacheControl"})}),"\n",(0,o.jsx)(n.p,{children:"Enables or disables caching for imported components"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-mathematica",children:"JerryI`WLX`Importer`Private`CacheControl[interval_String | True | False]\n"})}),"\n",(0,o.jsx)(n.p,{children:"The possible values for a time-interval are"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:'"Hour"'})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:'"Minute"'})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.M)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(a,{...e})}):a(e)}},2172:(e,n,s)=>{s.d(n,{I:()=>i,M:()=>r});var o=s(1504);const t={},l=o.createContext(t);function r(e){const n=o.useContext(l);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),o.createElement(l.Provider,{value:n},e.children)}}}]);