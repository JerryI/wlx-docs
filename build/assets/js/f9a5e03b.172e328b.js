"use strict";(self.webpackChunkwlx_docs=self.webpackChunkwlx_docs||[]).push([[3640],{5644:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var t=s(7624),i=s(2172);const a={sidebar_position:2},l="Basics of syntax",r={id:"WLX/basics",title:"Basics of syntax",description:"One can think about WLX as a WL and plain HTML got extended to each other. It allows you to write Wolfram Language using XML tags, and building HTML template using Wolfram Expressions.",source:"@site/docs/WLX/basics.md",sourceDirName:"WLX",slug:"/WLX/basics",permalink:"/wlx-docs/docs/WLX/basics",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedAt:1708366829,formattedLastUpdatedAt:"Feb 19, 2024",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Installation",permalink:"/wlx-docs/docs/WLX/install"},next:{title:"Scoping",permalink:"/wlx-docs/docs/WLX/scoping"}},o={},c=[{value:"Tags",id:"tags",level:2},{value:"Ownvalues and Downvalues",id:"ownvalues-and-downvalues",level:2},{value:"Simple rules is the key",id:"simple-rules-is-the-key",level:2},{value:"Keep only one or zero root XML element",id:"keep-only-one-or-zero-root-xml-element",level:3},{value:"Always close any XML tags",id:"always-close-any-xml-tags",level:3},{value:"Passing HTML attributes",id:"passing-html-attributes",level:2},{value:"How does it relate to a normal WL symbol?",id:"how-does-it-relate-to-a-normal-wl-symbol",level:2},{value:"Iterators, branching?",id:"iterators-branching",level:2},{value:"XML attributes = Options",id:"xml-attributes--options",level:2}];function d(e){const n={admonition:"admonition",annotation:"annotation",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",math:"math",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",...(0,i.M)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"basics-of-syntax",children:"Basics of syntax"}),"\n",(0,t.jsx)(n.p,{children:"One can think about WLX as a WL and plain HTML got extended to each other. It allows you to write Wolfram Language using XML tags, and building HTML template using Wolfram Expressions."}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsx)(n.p,{children:"Unlike JSX, you can write a plain HTML inside WLX scripts with no restrictions."})}),"\n",(0,t.jsx)(n.h2,{id:"tags",children:"Tags"}),"\n",(0,t.jsx)(n.p,{children:"It is easy to guess who is who"}),"\n",(0,t.jsxs)("div",{style:{display:"flex"},children:[(0,t.jsxs)("div",{style:{width:"48%",float:"left",clear:"left"},children:[(0,t.jsx)(n.p,{children:"HTML tag"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:"<div></div>\n"})})]}),(0,t.jsxs)("div",{style:{width:"48%",float:"right",clear:"right"},children:[(0,t.jsx)(n.p,{children:"Wolfram Expression"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:"<Div></Div>\n"})})]})]}),"\n",(0,t.jsxs)(n.p,{children:["There is no\xa0",(0,t.jsx)(n.code,{children:"html"}),"\xa0tags on Earth, that starts from the capital letter."]}),"\n",(0,t.jsx)(n.h2,{id:"ownvalues-and-downvalues",children:"Ownvalues and Downvalues"}),"\n",(0,t.jsx)(n.p,{children:"Those types of assignments are most commonly used in Wolfram Language. Thankfully HTML/XML tag syntax allows to make it clear, which one is called"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-mathematica",children:"TextString[Now]\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:"<TextString> <Now/> </TextString>\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"First child element is the first argument of a given function and etc."}),"\xa0Any self-closing tags represent an own-value of a symbol."]}),"\n",(0,t.jsx)(n.p,{children:"Any Number or String can be embedded as tag as well"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-mathematica",children:"<Plus/><1.0/><1.0/></Plus>\n"})}),"\n",(0,t.jsx)(n.h2,{id:"simple-rules-is-the-key",children:"Simple rules is the key"}),"\n",(0,t.jsx)(n.p,{children:"There are certain rules you should sticked to in order to write a valid WLX"}),"\n",(0,t.jsx)(n.h3,{id:"keep-only-one-or-zero-root-xml-element",children:"Keep only one or zero root XML element"}),"\n",(0,t.jsxs)(n.p,{children:["This implies that this one will be exported to the output, like in ",(0,t.jsx)(n.code,{children:"CompoundExpression"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-mathematica",children:'(* whatever WL code *)\nVar = "Hello World!";\n\n<body>\n\t<Var/>\n</body>\n'})}),"\n",(0,t.jsx)(n.p,{children:"This is good \ud83d\udc4d\ud83c\udffc"}),"\n",(0,t.jsx)(n.p,{children:"However it does not mean, you cannot have nested expressions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:"(* whatever WL code *)\nVar = <h1>Hello World!</h1>;\n\n<body>\n\t<Var/>\n</body>\n"})}),"\n",(0,t.jsx)(n.p,{children:"This is also good \ud83d\udc4d\ud83c\udffc"}),"\n",(0,t.jsx)(n.h3,{id:"always-close-any-xml-tags",children:"Always close any XML tags"}),"\n",(0,t.jsx)(n.p,{children:"Modern web-browsers are quite forgiving, when it comes to the syntax mistakes. All over the internet there is code like this"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:'<img src="http://...">\n'})}),"\n",(0,t.jsx)(n.p,{children:"This is wrong \ud83d\udc4e\ud83c\udffc  according to the convention of XML."}),"\n",(0,t.jsx)(n.p,{children:"WLX parser decodes the whole tree of XML and WL and, then, reconstructs it from AST. Therefore, always close tags explicitly"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:'<img src="http://..."/>\n'})}),"\n",(0,t.jsx)(n.p,{children:"Much better \ud83d\udc4d\ud83c\udffc"}),"\n",(0,t.jsxs)(n.admonition,{type:"tip",children:[(0,t.jsx)(n.p,{children:"Since WLX syntax is quite close to JSX, modern linters and syntax highlighting libraries can verify tags in WLX as well using JSX preset. Wolfram Expressions are quite hard to check, but in general, this comes very handy when you write a large script."}),(0,t.jsxs)(n.p,{children:["Avoid using ",(0,t.jsx)(n.code,{children:"@"}),", ",(0,t.jsx)(n.code,{children:"//"})," and wrap comments like in C ",(0,t.jsx)(n.code,{children:"(* /* */ *)"})," to reduce the number of warning from the JSX linter."]})]}),"\n",(0,t.jsx)(n.h2,{id:"passing-html-attributes",children:"Passing HTML attributes"}),"\n",(0,t.jsxs)(n.p,{children:["This is a crucial thing, when it comes to a markup. To maintain sort of compatibility with a well-established ",(0,t.jsx)(n.em,{children:"Handlebars"}),", ",(0,t.jsx)(n.em,{children:"JSX"}),"  ",(0,t.jsx)(n.strong,{children:"curly braces with double quotes"})," are used"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:'URL = "https://upload.wikimedia.org/wikipedia/commons/7/70/Oftheunicorn.jpg"\n<img width="300" src="{URL}"/>\n'})}),"\n",(0,t.jsx)(n.p,{children:"Since this is anyway a string, you can use it as a template"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:'URL = "upload.wikimedia.org/wikipedia/commons/7/70/Oftheunicorn.jpg"\n<img width="300" src="https://{URL}"/>\n'})}),"\n",(0,t.jsx)(n.p,{children:"Any Wolfram expressions are allowed inside the braces"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:'URL = {"upload.wikimedia.org/wikipedia/commons/7/70/Oftheunicorn.jpg"}\n<img width="300" src="https://{URL[[1]]}"/>\n'})}),"\n",(0,t.jsxs)(n.admonition,{type:"tip",children:[(0,t.jsxs)(n.p,{children:["To reduce a load on a garbage collector, please, use ",(0,t.jsx)(n.code,{children:"With"})]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:'With[{URL = "upload.wikimedia.org/wikipedia/commons/7/70/Oftheunicorn.jpg"},\t \n\t<img width="300" src="https://{URL}"/>\n]\n'})}),(0,t.jsx)(n.p,{children:"This prevents WL Kernel from creating temporal symbols"})]}),"\n",(0,t.jsx)(n.h2,{id:"how-does-it-relate-to-a-normal-wl-symbol",children:"How does it relate to a normal WL symbol?"}),"\n",(0,t.jsx)(n.p,{children:"What you have in those funky XML tags in the end is a normal WL definition. For example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:"\tAFunction[Any_] := <p><Any/></p>;\n\tAFunction[329]\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Once ",(0,t.jsx)(n.code,{children:".wlx"})," is parsed, it becomes a global definition. However the latter (whether it is global or defined like in ",(0,t.jsx)(n.code,{children:"Module"})," with a lexical scoping) you can still control, see [[WLX/scoping]]."]}),"\n",(0,t.jsx)(n.h2,{id:"iterators-branching",children:"Iterators, branching?"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"HTML/XML"}),"\xa0is a markup language by its nature. Therefore it is recommended not to use explicitly\xa0",(0,t.jsx)(n.code,{children:"Table"}),"\xa0or\xa0",(0,t.jsx)(n.code,{children:"If"}),"\xa0expressions inside XML tags, but rather utilize Wolfram Language for that"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:'Columns[YourList__]\xa0:=\xa0Table[\n\t<div\xa0class="lg:pr-4">\u2003\u2003\u2003\n\t\t<div\xa0class="text-base leading-7 text-gray-700\xa0">\n\t\t\t<Child/>\n\t\t</div>\n\t</div>\n, {Child,\xa0List[YourList]}];\n\n<div\xa0class="col">\n\t<Columns>\n\t\t<p>This is column 1</p>\n\t\t<p>This is column 2</p>\n\t\t<p>This is column 3</p>\n\t</Columns>\n</div>\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Here a multiple ",(0,t.jsx)(n.code,{children:"<p>"})," tags are substituted as a list of arguments to ",(0,t.jsx)(n.code,{children:"Columns"})," function, that iterates over them and forms a wrapper HTML structure. Then the result is substituted into the bottom ",(0,t.jsx)(n.code,{children:"div col"})," structure."]}),"\n",(0,t.jsx)(n.p,{children:"Or other there is another way to build lists from raw data"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:'With[{\n\tTableList = Table[ \n\t\tWith[{SomeField = item["Field"]},\n\t\t\t<li class="red"><SomeField/></li>\n\t\t]\n\t, {item, YouList}]\n},\n\t<ul>\n\t\t<TableList/>\n\t</ul>\n]\n'})}),"\n",(0,t.jsxs)(n.admonition,{type:"caution",children:[(0,t.jsx)(n.p,{children:"Putting a plain text separated by multiple line breaks"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:"<Element>\n\tLine 1\n\tLine 2\n</Element>\n"})}),(0,t.jsxs)(n.p,{children:["counts ",(0,t.jsx)(n.strong,{children:"as a single argument"})," to the expression ",(0,t.jsx)(n.code,{children:"Element"}),". However"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:"<Element>\n\tLine 1\n\t<p>Line 2</p>\n</Element>\n"})}),(0,t.jsxs)(n.p,{children:["is already ",(0,t.jsx)(n.strong,{children:"two arguments"})," passed with a string type (atom)."]})]}),"\n",(0,t.jsxs)(n.h2,{id:"xml-attributes--options",children:["XML attributes ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsx)(n.mrow,{children:(0,t.jsx)(n.mo,{children:"="})}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"="})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.3669em"}}),(0,t.jsx)(n.span,{className:"mrel",children:"="})]})})]})," Options"]}),"\n",(0,t.jsxs)(n.p,{children:["Traditional Wolfram Language ",(0,t.jsx)(n.code,{children:"Options"})," can be passed as if it was an HTML attribute"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:'<Heading title={"Some title"}/>\n'})}),"\n",(0,t.jsx)(n.p,{children:"where"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:'Heading[OptionsPattern[]] := With[{Title = OptionValue["title"]},\n\t<h1>This is some <Title/></h1>\n]\n\nOptions[Heading] = {"title" -> "Empty title"}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The only difference is ",(0,t.jsx)(n.strong,{children:"you have to use curly braces"})," unlike in traditional XML attributes for WL symbols."]}),"\n",(0,t.jsx)(n.p,{children:"This can be done for tags with child elements"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:"<TagName option1={Wolfram Expression} option2={...}>\n\twhatever\n</TagName>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["where all passed arguments ",(0,t.jsx)(n.strong,{children:"go firstly and before"})," the ",(0,t.jsx)(n.code,{children:"OptionsPattern"}),", i.e."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-mathematica",children:"TagName[args__, OptionsPattern[]] := ...\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.M)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},2172:(e,n,s)=>{s.d(n,{I:()=>r,M:()=>l});var t=s(1504);const i={},a=t.createContext(i);function l(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);